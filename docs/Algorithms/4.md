import Tabs from '@theme/Tabs';

import TabItem from '@theme/TabItem';

# 4 Data Structure
## Array

- 数组越界
- 数组是否可以重复,重复的处理

## LinkedList

*易错点:每一步p->next检查p!=NULL*

## Stack

*Basic Calculator*

Implement a basic calculator to evaluate a simple expression string.

The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces . The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate results will be in the range of [-2147483648, 2147483647]

```mdx-code-block
<Tabs>
<TabItem value="stack">
```

if there are no brackets, we could evaluate easily

if there are brackets, we could see each part = nonbracket + evaluate(bracket), but nonbracket should be store in a stack

Problems: evaluate(bracket) could be -3, so the new expression could contain 3*-3, 3+-3, 3--3. We need to handle those.

```cpp
int calculate(string &s) {
    stack<string> nonbracket;
    string curStr; 
    for(auto p: s){
        if(p=='('){
            nonbracket.push(curStr);
            curStr = "";
        }
        else if(p==')'){
            curStr = to_string(evaluate(curStr));
            curStr = nonbracket.top() + curStr;
            nonbracket.pop();
        }
        else if(p!=' ') curStr +=p;
    }
    return evaluate(curStr);
}
long long evaluate(string input){
    int i =0, j =0;
    long long base = 0, temp = 0;
    input = '+' + input;
    while(i<input.size()){
        if(input[i]=='+'||input[i]=='-'){
            base += temp;
            j = i+1;
            if(input[j]=='-')++j;
            while(isdigit(input[j]))++j;
            temp = stoll(input.substr(i+1,j-1-i));
            temp = input[i]=='+'?temp: -temp;
            i = j;
        }
        else if(input[i]=='*'||input[i]=='/'){
            j = i+1;
            if(input[j]=='-')++j;
            while(isdigit(input[j]))++j;
            if(input[i]=='*') temp *= stoll(input.substr(i+1,j-1-i));
            else temp /= stoll(input.substr(i+1,j-1-i));
            i = j;
        }
    }
    return base + temp;
}
```

```mdx-code-block
</TabItem>
<TabItem value="recursion">
```

for each character, if not empty space, make sure you are handling digits and is an operator before go to next step:
- if last character ')', break 
- '(': recursion(i+1)
- digit: transform from string to long long, i becomes operator when it is done

as we always start from digits, we will not handle operator every loop, and we could record last operator(or character)

```cpp
int calculate(string &s) {
    int i =0;
    return calHelper(s,i);
}
int calHelper(string &s,int &i){
    char op = '+';
    long long base=0, temp = 0;
    int n = s.size();
    while(i<n&&op!=')'){
        if(s[i]!=' '){
            long long num = 0;
            if(s[i] == '(')num = calHelper(s,++i);
            else{
                while(i<n&&isdigit(s[i])){
                    num = num*10 + s[i] - '0';
                    ++i;
                } 
            }
            if(op=='+'){
                base +=temp;
                temp = num;
            }
            else if(op == '-'){
                base +=temp;
                temp = -num;
            }
            else if(op == '*') temp *= num;
            else if(op == '/') temp /= num;
            if(i<n) op = s[i];
        }
        ++i;
    }
    return base + temp;
}
```
```mdx-code-block
</TabItem>
</Tabs>
```

### Monotonic Stack

- Mono-decreasing(pop smaller elements) stack keeps the result as greater as possible
- Mono-increasing stack keeps the result as smaller as possible 

## Deque

*Sliding Window Maximum*

You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;
    vector<int> ans;
    for(int i=0;i<nums.size();++i){
        while(!dq.empty()&&dq.front()<nums[i])dq.pop_front();
        dq.push_front(nums[i]);
        if(i-k>=0&&!dq.empty()&&dq.back()==nums[i-k])dq.pop_back();
        if(i>=k-1) ans.push_back(dq.back());
    }
    return ans;
}
```

## Hashmap
| Implement |contains(x) | add(x)|
|-|-|-|
|Bushy BSTs|Θ(log N)|Θ(log N)|
|Separate Chaining Hash Table With No Resizing|Θ(N)|Θ(N)|
|… With Resizing|Θ(1)|Θ(1)|

### Separate Chaining Data Indexed Array

Data is converted into a hash code. The hash code is then reduced to a valid index.

Java’s hashCode() function for Strings
```java
public int hashCode() {// From Left to right: High to Low
    int h = cachedHashValue;
    if (h == 0 && this.length() > 0) {
        for (int i = 0; i < this.length(); i++) {
            h = 31 * h + this.charAt(i);
        }
        cachedHashValue = h;
    }
    return h;
}
```

31: the hashCode base should be a small **prime** to avoid overflow

![20221120134556](https://raw.githubusercontent.com/zxc2012/image/main/20221120134556.png)


![20221120135107](https://raw.githubusercontent.com/zxc2012/image/main/20221120135107.png)

suppose the number of buckets: M, number of items: N

then complexities of contains and add are O(Q = N/M) 

To make them O(1), strategy: When N/M is ≥ 1.5, double M
 

```cpp
bool contains(int x, vector<list<int>>& hash_table){
    int n = hash_table.size();
    int index = (x%n + n)%n;
    list<int>& slot = hash_table[index]; 
    return find(slot.begin(),slot.end(),x)!=slot.end();
}
bool add(int x,vector<list<int>>& hash_table){
    int n = hash_table.size();
    int index = (x%n + n)%n;
    hash_table[index].push_back(x);
}
```

### Open Addressing 

An alternate way to handle collisions is to use open addressing

If target bucket is already occupied, use a different bucket
- Linear probing
    - Use next address, and if already occupied, just keep scanning one by one.
- Quadratic probing
    - Use next address, and if already occupied, try looking 4 ahead, then 9 ahead, then 16 ahead, ...