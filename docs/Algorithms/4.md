import Tabs from '@theme/Tabs';

import TabItem from '@theme/TabItem';

# 4 Data Structure
## Array

- 数组越界
- 数组是否可以重复,重复的处理

## LinkedList

*易错点:每一步p->next检查p!=NULL*

## Stack

*Basic Calculator*

Implement a basic calculator to evaluate a simple expression string.

The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces . The integer division should truncate toward zero.

You may assume that the given expression is always valid. All intermediate results will be in the range of [-2147483648, 2147483647]

```mdx-code-block
<Tabs>
<TabItem value="stack">
```

if there are no brackets, we could evaluate easily

if there are brackets, we could see each part = nonbracket + evaluate(bracket), but nonbracket should be store in a stack

Problems: evaluate(bracket) could be -3, so the new expression could contain 3*-3, 3+-3, 3--3. We need to handle those.

```cpp
int calculate(string &s) {
    stack<string> nonbracket;
    string curStr; 
    for(auto p: s){
        if(p=='('){
            nonbracket.push(curStr);
            curStr = "";
        }
        else if(p==')'){
            curStr = to_string(evaluate(curStr));
            curStr = nonbracket.top() + curStr;
            nonbracket.pop();
        }
        else if(p!=' ') curStr +=p;
    }
    return evaluate(curStr);
}
long long evaluate(string input){
    int i =0, j =0;
    long long base = 0, temp = 0;
    input = '+' + input;
    while(i<input.size()){
        if(input[i]=='+'||input[i]=='-'){
            base += temp;
            j = i+1;
            if(input[j]=='-')++j;
            while(isdigit(input[j]))++j;
            temp = stoll(input.substr(i+1,j-1-i));
            temp = input[i]=='+'?temp: -temp;
            i = j;
        }
        else if(input[i]=='*'||input[i]=='/'){
            j = i+1;
            if(input[j]=='-')++j;
            while(isdigit(input[j]))++j;
            if(input[i]=='*') temp *= stoll(input.substr(i+1,j-1-i));
            else temp /= stoll(input.substr(i+1,j-1-i));
            i = j;
        }
    }
    return base + temp;
}
```

```mdx-code-block
</TabItem>
<TabItem value="recursion">
```

for each character, if not empty space, make sure you are handling digits and is an operator before go to next step:
- if last character ')', break 
- '(': recursion(i+1)
- digit: transform from string to long long, i becomes operator when it is done

as we always start from digits, we will not handle operator every loop, and we could record last operator(or character)

```cpp
int calculate(string &s) {
    int i =0;
    return calHelper(s,i);
}
int calHelper(string &s,int &i){
    char op = '+';
    long long base=0, temp = 0;
    int n = s.size();
    while(i<n&&op!=')'){
        if(s[i]!=' '){
            long long num = 0;
            if(s[i] == '(')num = calHelper(s,++i);
            else{
                while(i<n&&isdigit(s[i])){
                    num = num*10 + s[i] - '0';
                    ++i;
                } 
            }
            if(op=='+'){
                base +=temp;
                temp = num;
            }
            else if(op == '-'){
                base +=temp;
                temp = -num;
            }
            else if(op == '*') temp *= num;
            else if(op == '/') temp /= num;
            if(i<n) op = s[i];
        }
        ++i;
    }
    return base + temp;
}
```
```mdx-code-block
</TabItem>
</Tabs>
```

## Deque