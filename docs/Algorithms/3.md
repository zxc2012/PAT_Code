import Tabs from '@theme/Tabs';

import TabItem from '@theme/TabItem';

# 3 Binary Search
*O(log(n))*

---
## 二分查找
在闭区间查找[begin,end],注意对找不到的处理
```cpp
int binary_find(vector<int>& nums, int target){
    int l=0,r=nums.size()-1;//Notice1
    while(l<r){
        int mid=l+(r-l)/2;//Notice2
        if(nums[mid]==target)return mid;
        else if(nums[mid]>target)r=mid-1;
        else l=mid+1;
    }
    return nums[l]==target?l:-1;
}
```
## 二分搜索
1. 在[begin,end)查找,故格外注意边界
2. 先想最终目标>or>=,然后满足条件时右不变,不满足时左加一
3. 注意变式如求上界(注释部分)

```cpp
int upper_bound(vector<int>& nums, int target){
    int l=0,n=nums.size();//Notice1
    int r=n;
    while(l<r){
        int mid=l+(r-l)/2);//Notice2
        if(nums[mid]>target)r=mid;
        else l=mid+1;
    }
    if(r==n||nums[l]!=target)return -1;
    else return l;
    /*
    if(l==0||nums[l-1]!=target)return -1;
    else return l-1;    
    */
}
int lower_bound(vector<int>& nums, int target){
    int l=0,n=nums.size();//Notice1
    int r=n;
    while(l<r){
        int mid=l+(r-l)/2);//Notice2
        if(nums[mid]>=target)r=mid;
        else l=mid+1;
    }
    if(r==n||nums[l]!=target)return -1;
    else return l;
}
```

## Two pointers
---
### Sliding Window

*Leetcode76*

Given two strings s and t of lengths m and n respectively, return the minimum window in s which will contain all the characters in t. If there is no such window in s that covers all characters in t, return the empty string ""
```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        fill(flag,flag+128,0);
        fill(each,each+128,0);
        int n=t.size();
        int m=s.size();
        int cap;
        int count=0,start=0,mini=m+1;//易错点1
        for(int i=0;i<n;++i)flag[t[i]]=1,each[t[i]]++;
        for(int i=0;i<m;++i){
            if(flag[s[i]]){
                if(--each[s[i]]>=0)count++;
                while(count==n){
                    if(i-start+1<mini){
                        mini=i-start+1;
                        cap=start;
                    }
                    if(flag[s[start]]&&++each[s[start]]>0)count--;
                    ++start;
                }
            }
        }
        return mini==m+1?"":s.substr(cap,mini);
    }
private:
    int flag[128];
    int each[128];
};
```

*Leetcode3*

Given a string s, find the length of the longest substring without repeating characters.

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        fill(each,each+128,0);
        int n=s.size();
        int start=0,maxi=0;
        for(int i=0;i<n;++i){
            char p=s[i];
            if(++each[p]>1){
                while(start<i&&s[start]!=p){
                    --each[s[start]];
                    ++start;
                }
                if(start!=i){
                    --each[s[start]];
                    ++start;
                }
            }   
            maxi=max(maxi,i-start+1);
        }
        return maxi;
    }
private:
    int each[128];
};
```

## Hash
---
分别给出N、M个正整数，问M个数是否在N个数中出现过?

- 遍历 *O(NM)*
- Hash *O(M+N)*

读入时即确定hashtable[x]=true or false

## Sort
### Brute Force

```cpp
//Selection sort
for(int i = 0; i< n-1; ++i){
    int min = i;
    for(int j = i+1; j<n; ++j)
        if(nums[j]<nums[min])min = j;
    swap(nums[i],nums[min]);
}
//Bubble sort
for(int i = 0; i< n-1; ++i){
    int flag = true;
    for(int j =0; j< n-1-i; ++j)
        if(nums[j+1]<nums[j]){
            swap(nums[j],nums[j+1]);
            flag = false;
        }
    if(flag == true)break;
}
```

### Decrease & Conquer

```cpp
//Insertion sort
for(int i = 0; i < n; ++i){
    int v = nums[i];
    j = i - 1;
    while(j>= 0 && nums[j] > v){
        nums[j + 1] = nums[j];
        j--;
    }
    nums[j+1] = v;
}
```

Shell’s Sort:

- compare items that are one stride length h apart. Do insertion sort.
- Start with large stride, and decrease towards 1

### Divide & Conquer

```mdx-code-block
<Tabs>
<TabItem value="mergesort">
```

模板

```cpp
void merge_sort(vector<int> &nums, int l, int r, vector<int> &temp) {
    if (r-l<=1) return; //Notice1
    // divide
    int mid = l + (r - l) / 2;
    merge_sort(nums, l, mid + 1, temp); // Notice2, [l,mid+1) = [l,mid]
    merge_sort(nums, mid + 1, r, temp);
    // conquer
    int p = l, q = mid, k = l;
    while (p < mid && q < r){
        if(nums[p]<nums[q]) temp[k++] = nums[p++];
        else temp[k++] = nums[q++];
    }
    while(p < mid)temp[k++] = nums[p++];
    while(q < r) temp[k++] = nums[q++];
    for (k = l; k < r; ++k)
        nums[k] = temp[k];
}
```

```cpp
// Leetcode 148 https://leetcode-cn.com/problems/sort-list/
ListNode* sortList(ListNode* head) {
    if(!head||!head->next)return head;
    //Find midium
    ListNode *slow = head,*fast = head;
    while(fast->next&&fast->next->next){
        slow = slow->next;
        fast = fast->next->next;
    }
    fast = slow->next;
    slow->next = NULL;
    slow = head;
    //divide
    slow=sortList(slow);fast=sortList(fast);
    //conquer
    ListNode * dummy = new ListNode(0);
    ListNode * node = dummy;
    while(slow&&fast){
        if(slow->val < fast->val){
            node->next = slow;
            slow = slow->next;
        }
        else{
            node->next = fast;
            fast = fast->next;
        }
        node = node->next;
    }
    node->next = slow?slow:fast;
    return dummy->next;
}
```

```mdx-code-block
</TabItem>
<TabItem value="quicksort">
```

```cpp
void quick_sort(int l,int r){//左闭右开
    if(r-l<=1)return;
    int first=l,last=r-1,key=nums[l];//保留pivot
    while(first<last){//先右再左，因为nums[first]可以被替换
        while(first<last&&nums[last]>=key)last--;
        nums[first]=nums[last];
        while(first<last&&nums[first]<=key)first++;
        nums[last]=nums[first];
    }
    nums[first]=key;
    quick_sort(l,first+1);
    quick_sort(first+1,r);
}
```

```mdx-code-block
</TabItem>
</Tabs>
```

### Transform & Conquer
#### Heap sort
- sink: **O(logn)**
- construct: bottom-up sink **O(n)**
- deletion: v[1] from 1 to (--n) sink **O(nlogn)**
- insert: v[n] up **O(logn)**

**变式:vector只对v[i]做v[i-1]变换即可**
```cpp
void sink(int val){
    while(2*val<=n){//最终是2*val
        int i=2*val;
        if(i+1<=n&&a[i+1]>a[i])i++;//易错点2
        if(a[i]>a[val])swap(a[i],a[val]);
        else return;
        val=i;
    }
}
void up(int val){//最终是val/2
    while(val>1&&a[val>>1]<a[val]){
        swap(a[val],a[val>>1]);
        val>>=1;
    }
}
int main(){
    for(int i=n>>1;i>=1;--i)sink(i);//construct heap
    while(--n){
        swap(a[1],a[n+1]);
        sink(1);
    }
}
```
*Leetcode215. Kth Largest Element in an Array*

[题目](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

法1:堆排序
```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int x) {
        k=x;
        n=nums.size();
        v=nums;
        //construct heap
        for(int i=n>>1;i>=1;--i)sink(i);
        int index=1;
        while(--n){
            swap(v[0],v[n]);
            if(index++==k)return v[n];
            sink(1);
        }
        return v[n];
    }
private:
    int k,n;
    vector<int> v;
    void swap(int& a,int& b){
        int x=a;
        a=b;
        b=x;
    }
    void sink(int val){
        while(2*val<=n){
            int i=2*val;
            if(i+1<=n&&v[i]>v[i-1])++i;
            if(v[i-1]>v[val-1])swap(v[i-1],v[val-1]);
            else return;
            val=i;
        }
    }
};
```
法2:快排
```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int x) {
        k=x;
        n=nums.size();
        v=nums;
        return quick_selection(0,n);
    }
private:
    int k,n;
    vector<int> v;
    int quick_selection(int l,int r){
        if(r-l<=0)return 0;
        int first=l,last=r-1,p=v[l];
        while(first<last){
            while(first<last&&v[last]>=p)last--;
            v[first]=v[last];
            while(first<last&&v[first]<=p)first++;
            v[last]=v[first];
        }
        v[first]=p;
        if(first==n-k)return v[n-k];
        else if(first<n-k)return quick_selection(first+1,r);
        else return quick_selection(l,first);
    }
};
```