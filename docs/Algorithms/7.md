# 7 DP
## 思路

(1)写状态方程
- 刷表法--考虑每个状态影响到的状态
- 填表法--考虑每个状态的依赖

(2)确定状态类型: has/remain情况下的**最优subproblem**

Eg: Knapsack
- has: 总体积不超过T的情况下最大重量dp[T]=dp[T-v[i]]+w[i]
- remain: 总体积实际剩余T时最大重量dp[T]=dp[T+v[i]]+w[i]

(3) Tabulation/ Memoization

- Tabulation: bottom up
    - 确定Iteration顺序: 是否会被当前大循环条件下决策所影响
- Memoization: Top down Recursion

```cpp
// Memoization solution of Fibonacci
int solve(int i){
    if(dp[i] ＞= 0) return dp[i];
	if(i==1 || i==2){
		dp[i]=1;
	}
    else{
		dp[i] = solve(i-1) + solve(i-2);
	}
    return dp[i];
}
```
:::tip

1. 最后的处理

    求端点值 or 求min/max_element

2. 涉及求字典序(或涉及dp的序号获取)

- 法1:去掉不可达结点，初始化为-inf(max)inf(min)
- 法2:加入实际has数组

:::

## Linear DP
### Longest Consecutive Sequence

末尾来源连续

### Longest Increasing Subsequence

Solution1: O($n^2$)

LISEnding(n): length of longest increasing sub-sequence that ends in A[n]

LISEnding(i) = max(LISEnding(j) + 1, LISEnding(i)), A[j] < A[i]

Solution2: Since we do not care about particular LISEnding, we could use binary search to set dp[i]: the largest encoding number that forms i increasing subsequences.

```cpp
for(int j=0;j<m;++j){
    *lower_bound(dp,dp+m,x)=x;
}
```

变式: Perfect Squares

Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum are equal to n.

dp[i] = 1 + $\min_{1\leq j^2\leq i}dp[i - j^2]$

Runtime: O(nlogn)

### Longest Common Subsequence

末尾来源:交叉两种, 故加个空间保存上一行即可

Runtime: O(mn)

```cpp
for(int i=0;i<strlen(a);++i){
    for(int j=0;j<strlen(b);++j){
        if(a[i]==b[j])dp[j]=(j-1<0?0:last[j-1])+1;
        else dp[j]=max(j-1<0?0:dp[j-1],last[j]);
    }
    last=dp;
}
```

变式: Edit Distance

distance between strings = gaps + mismatches

![20230603164943](https://raw.githubusercontent.com/zxc2012/image/main/20230603164943.png)

Given two strings, find an alignment with the minimum edit distance

```cpp
dp[j] = min(xi!=yi + last[j-1], 
                1 + last[j], // gap in xi
                1 + dp[j-1]   // gap in yj
)
```
### Knapsack
#### Unbounded knapsack problem

maximize $\sum_{i=1}^nv_ix_i$ subject to $\sum_{i=1}^nw_ix_i \leq W, x_i\in N$

Recursion方向: 考虑$x_i$时, 要被当前$x_i$影响

Runtime: O(mn)

```cpp
for(int i=0;i<m;++i){
    scanf("%d%d",&v,&p);
    // has思路, 回溯为小, 故递增方向求dp[n]
    for(int j=v;j<=n;++j)
    dp[j]=max(dp[j],dp[j-v]+v*p);
    // remain思路, 回溯为大，故递减方向求dp[0]
    // for(int j=n-v;j>=0;--j)
    // dp[j]=max(dp[j],dp[j+v]+v*p);
}
```

#### 0-1 Knapsack

maximize $\sum_{i=1}^nv_ix_i$ subject to $\sum_{i=1}^nw_ix_i \leq W, x_i\in\{0,1\}$

Iteration方向: 考虑$x_i$时, 不能被当前$x_i$影响

Runtime: O(mn)

```cpp
for(int i=0;i<m;++i){
    scanf("%d%d",&v,&p);
    // has思路, 回溯为小, 故递减求dp[n]
    for(int j=n;j>=v;--j)
    dp[j]=max(dp[j],dp[j-v]+v*p);
    // remain思路, 回溯为大, 故递增求dp[0]
    // for(int j=0;j<=n-v;++j)
    // dp[j]=max(dp[j],dp[j+v]+v*p);
}
```

### Longest Palindromic Subsequence

Given a string s, find the longest palindromic subsequence's length in s.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

区间型: 左右皆可变, 大循环考虑length, 小循环考虑端点

```cpp
for(int i = 0 ;i < n;++i)dp[i][i] = 1; // length = 0
for(int j = 1;j < n;++j)
for(int i = 0;i + j < n; ++i){
    dp[i][i + j] = max(dp[i][i + j],dp[i + 1][i + j], dp[i][i + j -1]);
    if(a[i] == a[i + j]) dp[i][i+j] = max(dp[i][i+j],dp[i+1][i+j-1] + 2);
}
```