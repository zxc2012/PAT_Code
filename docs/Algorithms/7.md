# 7 DP
## æ€è·¯

(1)å†™çŠ¶æ€æ–¹ç¨‹
- åˆ·è¡¨æ³•--è€ƒè™‘æ¯ä¸ªçŠ¶æ€å½±å“åˆ°çš„çŠ¶æ€
    - åªæœ‰å½“æ¯ä¸ªçŠ¶æ€æ‰€ä¾èµ–çš„çŠ¶æ€å¯¹å®ƒçš„å½±å“ç›¸äº’ç‹¬ç«‹æ—¶æ‰èƒ½ç”¨åˆ·è¡¨æ³•
- å¡«è¡¨æ³•--è€ƒè™‘æ¯ä¸ªçŠ¶æ€çš„ä¾èµ–

(2)ç¡®å®šçŠ¶æ€ç±»å‹: has/remainæƒ…å†µä¸‹çš„**æœ€ä¼˜subproblem**

Eg: Knapsack
- has: æ€»ä½“ç§¯ä¸è¶…è¿‡Tçš„æƒ…å†µä¸‹æœ€å¤§é‡é‡dp[T]=dp[T-v[i]]+w[i]
- remain: æ€»ä½“ç§¯å®é™…å‰©ä½™Tæ—¶æœ€å¤§é‡é‡dp[T]=dp[T+v[i]]+w[i]

(3) Tabulation/ Memoization

- Tabulation: bottom up
    - ç¡®å®šIterationé¡ºåº: æ˜¯å¦ä¼šè¢«å½“å‰å¤§å¾ªç¯æ¡ä»¶ä¸‹å†³ç­–æ‰€å½±å“
    - ç¡®å®šè¾¹ç•Œ: æ ¹æ®æ•°ç»„è¾¹ç•Œ, ä½†è®°å¾—é¢å¤–å¤„ç†
- Memoization: Top down Recursion

```cpp
// Memoization solution of Fibonacci
int solve(int i){
    if(dp[i] ï¼= 0) return dp[i];
	if(i==1 || i==2){
		dp[i]=1;
	}
    else{
		dp[i] = solve(i-1) + solve(i-2);
	}
    return dp[i];
}
```
:::tip

1. æœ€åçš„å¤„ç†

    æ±‚ç«¯ç‚¹å€¼ or æ±‚min/max_element

2. æ¶‰åŠæ±‚å­—å…¸åº(æˆ–æ¶‰åŠdpçš„åºå·è·å–)

- æ³•1:å»æ‰ä¸å¯è¾¾ç»“ç‚¹ï¼Œåˆå§‹åŒ–ä¸º-inf(max)inf(min)
- æ³•2:åŠ å…¥å®é™…hasæ•°ç»„

:::

## Linear DP
### Longest Consecutive Sequence

æœ«å°¾æ¥æºè¿ç»­

### Longest Increasing Subsequence

Solution1: O($n^2$)

LISEnding(n): length of longest increasing sub-sequence that ends in A[n]

LISEnding(i) = max(LISEnding(j) + 1, LISEnding(i)), A[j] < A[i]

Solution2: Since we do not care about particular LISEnding, we could use binary search to set dp[i]: the largest encoding number that forms i increasing subsequences.

```cpp
for(int j=0;j<m;++j){
    *lower_bound(dp,dp+m,x)=x;
}
```

å˜å¼: Perfect Squares

Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum are equal to n.

dp[i] = 1 + $\min_{1\leq j^2\leq i}dp[i - j^2]$

Runtime: O(nlogn)

### Longest Common Subsequence

æœ«å°¾æ¥æº:äº¤å‰ä¸¤ç§, æ•…åŠ ä¸ªç©ºé—´ä¿å­˜ä¸Šä¸€è¡Œå³å¯

Runtime: O(mn)

```cpp
for(int i=0;i<strlen(a);++i){
    for(int j=0;j<strlen(b);++j){
        if(a[i]==b[j])dp[j]=(j-1<0?0:last[j-1])+1;
        else dp[j]=max(j-1<0?0:dp[j-1],last[j]);
    }
    last=dp;
}
```

å˜å¼: Edit Distance

distance between strings = gaps + mismatches

![20230603164943](https://raw.githubusercontent.com/zxc2012/image/main/20230603164943.png)

Given two strings, find an alignment with the minimum edit distance

```cpp
dp[j] = min(xi!=yi + last[j-1], 
                1 + last[j], // gap in xi
                1 + dp[j-1]   // gap in yj
)
```
### Knapsack
#### Unbounded knapsack problem

maximize $\sum_{i=1}^nv_ix_i$ subject to $\sum_{i=1}^nw_ix_i \leq W, x_i\in N$

Recursionæ–¹å‘: è€ƒè™‘$x_i$æ—¶, è¦è¢«å½“å‰$x_i$å½±å“

Runtime: O(mn)

```cpp
for(int i=0;i<m;++i){
    scanf("%d%d",&v,&p);
    // hasæ€è·¯, å›æº¯ä¸ºå°, æ•…é€’å¢æ–¹å‘æ±‚dp[n]
    for(int j=v;j<=n;++j)
    dp[j]=max(dp[j],dp[j-v]+v*p);
    // remainæ€è·¯, å›æº¯ä¸ºå¤§ï¼Œæ•…é€’å‡æ–¹å‘æ±‚dp[0]
    // for(int j=n-v;j>=0;--j)
    // dp[j]=max(dp[j],dp[j+v]+v*p);
}
```

#### 0-1 Knapsack

maximize $\sum_{i=1}^nv_ix_i$ subject to $\sum_{i=1}^nw_ix_i \leq W, x_i\in\{0,1\}$

Iterationæ–¹å‘: è€ƒè™‘$x_i$æ—¶, ä¸èƒ½è¢«å½“å‰$x_i$å½±å“

Runtime: O(mn)

```cpp
for(int i=0;i<m;++i){
    scanf("%d%d",&v,&p);
    // hasæ€è·¯, å›æº¯ä¸ºå°, æ•…é€’å‡æ±‚dp[n]
    for(int j=n;j>=v;--j)
    dp[j]=max(dp[j],dp[j-v]+v*p);
    // remainæ€è·¯, å›æº¯ä¸ºå¤§, æ•…é€’å¢æ±‚dp[0]
    // for(int j=0;j<=n-v;++j)
    // dp[j]=max(dp[j],dp[j+v]+v*p);
}
```

### Longest Palindromic Subsequence

Given a string s, find the longest palindromic subsequence's length in s.

A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

åŒºé—´å‹: å·¦å³çš†å¯å˜, å¤§å¾ªç¯è€ƒè™‘length, å°å¾ªç¯è€ƒè™‘ç«¯ç‚¹

```cpp
for(int i = 0 ;i < n;++i)dp[i][i] = 1; // length = 0
for(int j = 1;j < n;++j)
for(int i = 0;i + j < n; ++i){
    dp[i][i + j] = max(dp[i][i + j],dp[i + 1][i + j], dp[i][i + j -1]);
    if(a[i] == a[i + j]) dp[i][i+j] = max(dp[i][i+j],dp[i+1][i+j-1] + 2);
}
```

## DAG

Suppose we have labelled the vertices such that (i,j) is a directed edge only if ğ‘– < ğ‘—.

from the topological sort, we can define DP functions.

![20230607111952](https://raw.githubusercontent.com/zxc2012/image/main/20230607111952.png)

### Tour

John Doe, a skilled pilot, enjoys traveling. While on vacation, he rents a small plane and starts visiting beautiful places. To save money, John must determine the shortest closed tour that connects his destinations. Each destination is represented by a point in the plane pi = <xi,yi>. John uses the following strategy: he starts from the leftmost point, then he goes strictly left to right to the rightmost point, and then he goes strictly right back to the starting point. It is known that the points have distinct x-coordinates.

Write a program that, given a set of n points in the plane, computes the shortest closed tour that connects the oints according to John's strategy.

:::tip
æœ€ä¼˜å­ç»“æ„æ˜¾ç„¶æ— æ³•ä»rightmostç‚¹å…¥æ‰‹, ä¸Šä¸‹ä¸¤æ¡æ˜¯äº’ç›¸å¹³è¡Œä¸ç›¸äº¤çš„æŠ˜çº¿-> è€ƒè™‘æŸæ—¶åˆ»ä¸Šè·¯åœåœ¨iç‚¹, ä¸‹è·¯åœåœ¨jç‚¹, å¯è€ƒè™‘max(i,j) = rightmost

ä¸éš¾å‘ç°dp[i][j] = dp[j][i], ä¸ºé¿å…é‡å¤, å¯ä»¥åªè€ƒè™‘i > jçš„æƒ…å†µ

è¿™æ ·è€ƒè™‘dp[i][j]ä¸Šä¸‹è·¯åˆ†åˆ«å¾€rightmostèµ°ä¸€æ­¥åªä¼šäº§ç”Ÿä¸¤ç§å˜åŒ–: dp[i + 1][j] å’Œ dp[i + 1][i](å®é™…æ˜¯dp[i][i + 1])

å¯¹äºçŠ¶æ€æ–¹ç¨‹ä¹Ÿæœ‰ä¸¤ç§æ€è·¯
- åˆ·è¡¨æ³•: å»ºç«‹has, i = 0:n - 1, j = 0: i, ä½†è¦æ³¨æ„çš„æ˜¯dp[i][i]åœ¨i = 0æ—¶å¯ä»¥å­˜åœ¨ï¼Œéœ€å•ç‹¬å¤„ç†
- å¡«è¡¨æ³•: å»ºç«‹remain, è¿™æ ·åªéœ€è¦ä¸€ä¸ªæ–¹ç¨‹, iterationé¡ºåºå¾—æ˜¯n-1: 0, å¦å¤–i = n-1 æ—¶éœ€è¦å•ç‹¬å¤„ç†
:::

```cpp
int solution1(){// åˆ·è¡¨æ³•
    dp[1][0] = d(0,1);
    for(int i = 0;i< n-1;++i)for(int j =0 ;j<i;++j){
        dp[i + 1][j] = dp[i][j] + d(i, i + 1);
        if(dp[i + 1][i] ==0) dp[i + 1][i] = dp[i][j] + d(j,i + 1);
        else dp[i + 1][i] = min(dp[i + 1][i], dp[i][j] + d(j, i + 1);
    } 
    printf("%.2f\n",dp[n-1][n-2]+d(n-2,n-1));
}
int solution2(){// å¡«è¡¨æ³•
    for(int i = n-1;i>=0;--i)for(int j =0 ;j<i;++j){
        if(i == n-1)dp[i][j] = d(j,i);
        else dp[i][j] = min(dp[i + 1][j] + d(i + 1,i),
                        dp[i +1][i] + d(j, i + 1)
        );
    } 
    printf("%.2f\n",dp[1][0]+d(0,1));
}
```