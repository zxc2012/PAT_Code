# CS61C Lecture6 --Virtual Memory
## Basic

Virtual Memory Goals
- Allow multiple processes to simultaneously occupy memory and provide **protection**: Don’t let programs read/write each other’s memory
- Give each program the illusion that it has its
own **private address space**

![20220603203635](https://raw.githubusercontent.com/zxc2012/image/main/20220603203635.png)

Processes use **virtual addresses**
- Divided into pages indexed by virtual page number(VPN)

Memory uses **physical addresses**
- Divided into pages indexed by phisical page number(PPN)

## Virtual Memory and Page Tables
### Paged Memory

Base & Bound Machine

![20221126210452](https://raw.githubusercontent.com/zxc2012/image/main/20221126210452.png)

Problems
- May need more space than segment allows
- External Fragmentation: Free chunks between allocated regions

    ![20230105233347](https://raw.githubusercontent.com/zxc2012/image/main/20230105233347.png)

- Internal Fragmentation: Space inside allocated address space may not be fully used

    ![20230105233503](https://raw.githubusercontent.com/zxc2012/image/main/20230105233503.png)

Paged Memory

Instead of having segments of various sizes, divide physical memory and virtual memory into equal units called *pages*
- Pages are the same size in both virtual and physical memory, and RAM is an integer multiple of pages
- Each program has access to one or more pages(do not have to be contiguous)

![20220603214957](https://raw.githubusercontent.com/zxc2012/image/main/20220603214957.png)

### Address Translation

Virtual/Physical addresses can be broken into page number + offset(much likeT/I/O)

- Memory Size = $2^{Address}$ Bytes
- Page size Bytes = $2^{Offset}$ Bytes
- VPN/PPN = log_2(# of pages) = log_2(Memory Size/page size)

![20220603214329](https://raw.githubusercontent.com/zxc2012/image/main/20220603214329.png)

![20220603214355](https://raw.githubusercontent.com/zxc2012/image/main/20220603214355.png)

![20221126221332](https://raw.githubusercontent.com/zxc2012/image/main/20221126221332.png)

### Page Table Entry

Each program has a page table

- Dirty bit: Page has been modified recently
- Valid bit
    - 1: virtual page is in physical memory
    - 0: OS needs to fetch page from disk(Page Fault)
- Permission bits: Access Rights checked on every access to see if allowed (else protection fault)
    - Read, Write, Executable
- PPN

![20220603215849](https://raw.githubusercontent.com/zxc2012/image/main/20220603215849.png)

Example: 

If we ignore the valid and permission bits, assume that page table entry only contains PPN

Number of pages needed by Page table = $\frac{2^{VPN}\times PPN}{8\times pagesize}$

### Page Fault

On Page Table Miss

- Load the page off the disk into a free page of memory. Switch to some other process while we wait
- Interrupt thrown when page loaded and the process’ page table is updated. When we switch back to the task, the desired data will be in memory
- If memory full, replace page (LRU), writing back if necessary, and update both page table entries. Continuous swapping between disk and memory called "thrashing"

### Hierarchical Page Table

Linear Page Table

PT Base Register: stores Physical Address of current
Page Table

![20221127214128](https://raw.githubusercontent.com/zxc2012/image/main/20221127214128.png)

Problems:
- can be really large (span multiple pages), and sparsely populated
- have to load the entire page table(may only need sections)

Hierarchical Page Table

![20221127214634](https://raw.githubusercontent.com/zxc2012/image/main/20221127214634.png)

![20221127214602](https://raw.githubusercontent.com/zxc2012/image/main/20221127214602.png)

## Translation Lookaside Buffer (TLB)

Virtual Memory Problem: 2+ physical memory accesses per data access
= SLOW

Build a separate cache for the Page Table: TLB

TLB vs Cache

- TLBs usually small, typically 32–128 entries
- TLB access time comparable to cache (much faster than accessing main memory)
- TLBs usually are fully/highly associativity

![20221127220733](https://raw.githubusercontent.com/zxc2012/image/main/20221127220733.png)

![20221127220842](https://raw.githubusercontent.com/zxc2012/image/main/20221127220842.png)

### TLB Entry Format

- Valid: whether that TLB ENTRY is valid (unrelated to PT)
- Ref: Used to implement LRU, set when page is accessed, cleared periodically by OS
- Access Rights: Data from the PT
- Dirty: Consistent with PT
- PPN: Data from PT
- VPN: Data from PT