# CS61C Lecture6 --Virtual Memory
## Memory Basic
### Memory Multiplexing

MMU(Memory Management Unit) converts virtual to physical

![20230221203545](https://raw.githubusercontent.com/zxc2012/image/main/20230221203545.png)

Different Processes/Threads share the same hardware
- Need to multiplex CPU (Scheduling)
- Need to multiplex use of Memory (Virtual Memory)

Important Aspects of Memory Multiplexing
- Multiplexing: Allow multiple processes to simultaneously occupy memory
- Protection: Prevent access to private memory of other processes
- Translation: Give each program the illusion that it has its own private address space, and then translate accesses from virtual to physical

![20220603203635](https://raw.githubusercontent.com/zxc2012/image/main/20220603203635.png)

### Base & Bound Machine

![20221126210452](https://raw.githubusercontent.com/zxc2012/image/main/20221126210452.png)

Problems
- May need more space than segment allows
- External Fragmentation: Free chunks between allocated regions

    ![20230105233347](https://raw.githubusercontent.com/zxc2012/image/main/20230105233347.png)

- Internal Fragmentation: Space inside allocated address space may not be fully used

    ![20230105233503](https://raw.githubusercontent.com/zxc2012/image/main/20230105233503.png)

### Simple Segmentation

if I have 16 bit address with 4 segments (code, data, stack, heap), use 2 segment bits

![20230221215032](https://raw.githubusercontent.com/zxc2012/image/main/20230221215032.png)

Pros: Minimize internal fragmentation

Cons: Still External fragmentation

## Address Translation
### Simple Paging

Instead of having segments of various sizes, divide physical memory and virtual memory into equal units called *pages*
- Pages are the same size in both virtual and physical memory, and RAM is an integer multiple of pages
- Avoids internal fragmentation: Each program has access to one or more pages(do not have to be contiguous)

Virtual/Physical addresses can be broken into page number + offset(much likeT/I/O)

- Memory Size = $2^{Address}$ Bytes
- Page size Bytes = $2^{Offset}$ Bytes
- VPN/PPN = log_2(# of pages) = log_2(Memory Size/page size)

Virtual addresses: Divided into pages indexed by virtual page number(VPN)

![20220603214329](https://raw.githubusercontent.com/zxc2012/image/main/20220603214329.png)

Physical addresses: Divided into pages indexed by phisical page number(PPN) or frame number

![20220603214355](https://raw.githubusercontent.com/zxc2012/image/main/20220603214355.png)

Example 

![20220603214957](https://raw.githubusercontent.com/zxc2012/image/main/20220603214957.png)

#### Page Table Entry

Each program has a page table, whose address store in PTBR(Page Table Base Register)

PTBR value saved/restored in PCB on context switch

- Dirty bit: Page has been modified recently
- Valid bit
    - 1: virtual page is in physical memory
    - 0: OS needs to fetch page from disk(Page Fault)
- Permission bits: Access Rights checked on every access to see if allowed (else protection fault)
    - Read, Write, Executable
- PPN

![20220603215849](https://raw.githubusercontent.com/zxc2012/image/main/20220603215849.png)

Example: 

If we ignore the valid and permission bits, assume that page table entry only contains PPN

Number of pages needed by Page table = $\frac{2^{VPN}\times PPN}{8\times pagesize}$

#### Problems

32 bit processor, 12 bit offset-> 4KB page size
> Memory = $2^{20}$ * 4 bytes(20 + valid bit + permission bits) = 4 MB

64 bit processor, 12 bit offset
> Memory = $2^{52}$ * 8 bytes(52 + ...) = ridiculous!

Problems:
- can be really large (span multiple pages), and sparsely populated
- have to load the entire page table(may only need sections)

### Multi-Level Paging

![20221127214634](https://raw.githubusercontent.com/zxc2012/image/main/20221127214634.png)

![20230225224712](https://raw.githubusercontent.com/zxc2012/image/main/20230225224712.png)

### Inverted Page Table

Physical memory < Virtual memory: Much of process space may be out on disk or not in use

![20230221222300](https://raw.githubusercontent.com/zxc2012/image/main/20230221222300.png)

use a hash table
- Size Directly related to amount of physical memory
- Very attractive option for 64-bit address spaces: PowerPC, UltraSPARC, IA64

Cons
- Complexity of managing hash chains: Often in hardware!
- Poor cache locality of page table

### Address Translation Comparison

<table>
<tr><th></th><th>Advantages</th><th>Disadvantages</th></tr>
<tr><td>Simple Segmentation</td><td>Fast context switching (segment map maintained by CPU)</td><td>External fragmentation</td></tr>
<tr><td>Simple Paging</td><td>1.No external fragmentation 2.Fast and easy allocation</td><td>1.Large table size(~ virtual memory) 2.Internal fragmentation</td></tr>
<tr><td>Multi-Level Paging</td><td>1.Table size ~ # of pages in virtual memory 2.Fast and easy allocation</td><td>Multiple memory references per page access</td></tr>
<tr><td>Inverted Page Table</td><td>Table size ~ # of pages in physical
memory</td><td>1.Hash function more complex 2.No cache locality of page table</td></tr>
</table>

## Translation Lookaside Buffer (TLB)

MMU Problem: 2+ physical memory accesses per data access = SLOW

Build a separate cache for the Page Table: TLB

**TLB vs Cache**

- TLBs usually small, typically 32–128 entries
- TLB access time comparable to cache (much faster than accessing main memory)
- TLBs usually are fully/highly associativity

![20221127220733](https://raw.githubusercontent.com/zxc2012/image/main/20221127220733.png)

![20221127220842](https://raw.githubusercontent.com/zxc2012/image/main/20221127220842.png)

**Page Locality**

- Instruction accesses spend a lot of time on the same page (since accesses sequential)
- Stack accesses have definite locality of reference

### TLB Entry Format

- Valid: whether that TLB ENTRY is valid (unrelated to PT)
- Ref: Used to implement LRU, set when page is accessed, cleared periodically by OS
- Access Rights: Data from the PT
- Dirty: Consistent with PT
- PPN: Data from PT
- VPN: Data from PT

## Paging Questions
### Contex Switch

Address Space just changed, so TLB entries no longer valid

Options

1. Invalidate TLB: simple but might be expensive 
2. Include ProcessID in TLB: needs hardware

### Page Fault

On Page Table Miss

- Load the page off the disk into a free page of memory. Switch to some other process while we wait
- Interrupt thrown when page loaded and the process’ page table is updated. When we switch back to the task, the desired data will be in memory
- If memory full, replace page (LRU), writing back if necessary, and update both page table entries. Continuous swapping between disk and memory called "thrashing"

### Copy on Write