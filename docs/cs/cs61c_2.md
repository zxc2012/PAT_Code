# CS61C Lecture2 --RISCV Assembly

## RISC-V Architecture
- Register Size: 1 word = 32 bits = 4 bytes

- 32 registers:

    x0(holds the value zero)-x31

    ![20220310173933](https://raw.githubusercontent.com/zxc2012/image/main/20220317214717.png)

- Byte Ordering 

    Little Endian(x86, ARM)

    ![20220310173933](https://raw.githubusercontent.com/zxc2012/image/main/20220316203925.png)

## RISC-V Instructions

### Assembly Syntax

![20220310173933](https://raw.githubusercontent.com/zxc2012/image/main/20220316201927.png)

1. no-op: an instruction that does nothing

    ```armasm
    add x0,x0,x0  # Writes to x0 are always ignored
    ```

2. immediates

- RISC-V immediates are "sign extended"(the upper bits are the same as the largest bit)

- for a 12b immediate, Bits 31:12 get the same value as Bit 11

3. Loading and Storing Bytes

- Transfer from Register to Memory: sw/sb

    ![20220317204056](https://raw.githubusercontent.com/zxc2012/image/main/20220317204056.png)
    
    on sb, upper 24 bits are ignored

    ![20220317204139](https://raw.githubusercontent.com/zxc2012/image/main/20220317204139.png)

- Transfer from Memory to Register: lw/lb

    on lb, upper 24 bits are filled by sign-extension

    ![20220317204338](https://raw.githubusercontent.com/zxc2012/image/main/20220317204338.png)

    For e.g.,  s0 = 0x00000180 (all 32 bits)

    ```armasm
    lb s1,1(s0) # s1 = 0x00000001
    lb s2,0(s0) # s2 = 0xFFFFFF80
    sb s2,2(s0) # *(s0) = 0x00800180
    ```

    *常见错误*
    ```armasm
    add x10,x11,4(x12) # 必须先lw再add
    ```
4. branches
- conditional branch
    - branch if equal (beq) or branch if not equal (bne)
    - branch if less than (blt) and branch if greater than or equal (bge)
- unconditional branch
    ```armasm
    j label # pseudo-code 
    jal dst label # Writes PC+4 to dst, set PC=lable
    jalr dst src imm # Writes PC+4 to dst, set PC=src+imm
    jr ra # pseudo-code:ret = jr ra = jalr x0, ra, 0
    ```

### Example 

C Loop Mapped to RISC-V Assembly
```c
int A[20];
int sum = 0;
for (int i=0; i<20; i++)
sum +=  A[i];
```

```armasm
# Assume x8 holds pointer to A
# Assign x10=sum
add x10, x0, x0 # sum=0
add x11, x0, x8 # Copy of A
addi x12,x11, 80 # x12=80 + A
loop:
    lw x13, 0(x11)
    add x10, x10, x13
    addi x11, x11, 4
    blt x11, x12, loop
```

## Calling a function

Callee Saved
- s0-s11 (saved registers)
- sp (stack	pointer)

Caller Saved
- t0-t6 (temporary registers)
- a0-a7 (function arguments)
- ra (return address)

```armasm
Prologue:
addi sp,sp, -framesize
sw ra, <framesize-4>(sp) # 次二高,随后逐级递减
#store other callee saved registers
#save other regs if need be
Body:

Epilogue:
#restore other regs if need be
#restore other callee saved registers
lw ra, <framesize-4>(sp)
addi sp,sp, framesize
jr ra
```

E.g.
```c
int sumSquare(int x, int y) {
    return mult(x,x)+ y; 
}
```

```armasm
# Prologue
addi sp,sp,-8 # make space on stack
sw ra, 4(sp) # save ret addr
sw a1, 0(sp) # save y
add a1,a0,x0 # set 2nd mult arg

# Body
jal mult # call mult

# Epilogue
lw a1, 0(sp) # restore y
add a0,a0,a1 # ret val = mult(x,x)+y
lw ra, 4(sp) # get ret addr
addi sp,sp,8 # restore stack
jr ra

mult: 
```

## Instruction Format

- R format
    ![20220319150921](https://raw.githubusercontent.com/zxc2012/image/main/20220319150921.png)

- I format
    ![20220319150829](https://raw.githubusercontent.com/zxc2012/image/main/20220319150829.png)

- S format (rs1--transfer的结果)
    ![20220319151811](https://raw.githubusercontent.com/zxc2012/image/main/20220319151811.png)

- SB format
    imm: lowest bit of offset is always zero, so no need to store it.
    
    $-2^{12}$ to $2^{12}-2$ = offset(byte)
    ![20220319151813](https://raw.githubusercontent.com/zxc2012/image/main/20220319152721.png)

- U format
    ![20220319162528](https://raw.githubusercontent.com/zxc2012/image/main/20220319162528.png)

    ```armasm
    # Load Upper Immediate
    lui rd, immediate   #rd = (immediate[31:12] << 12)
    # Add Upper Immediate to PC
    auipc rd, immediate    #rd = pc+(immediate[31:12] << 12)
    ```

    E.g. How to set 0xDEADBEEF?

    ```armasm
    # Wrong answer
    lui x10, 0xDEADB # x10 = 0xDEADB000
    addi x10, x10,0xEEF # if top bit of the 12-bit immediate is a 1, it will subtract -1 from upper 20 bits,thus x10 = 0xDEADAEEF
    
    # Right
    lui x10, 0xDEADC # x10 = 0xDEADC000
    addi x10, x10,0xEEF # x10 = 0xDEADBEEF

    #  Call function at any 32-bit absolute address
    lui x1, <hi 20 bits>
    jalr ra, x1, <lo 12 bits>

    # Jump PC-relative with 32-bit offset
    auipc x1, <hi 20 bits>
    jalr x0, x1, <lo 12 bits>
    ```

- UJ format

    ![20220319162528](https://raw.githubusercontent.com/zxc2012/image/main/20220319164352.png)