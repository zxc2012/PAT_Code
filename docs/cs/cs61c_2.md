# CS61C Lecture2 --RISCV Assembly

## RISC-V Architecture
- Register Size: 1 word = 32 bits = 4 bytes

- 32 registers:

    x0(holds the value zero)-x31

    ![20220310173933](https://raw.githubusercontent.com/zxc2012/image/main/20220317214717.png)

- Byte Ordering 

    Little Endian(x86, ARM)

    ![20220310173933](https://raw.githubusercontent.com/zxc2012/image/main/20220316203925.png)

## RISC-V Instructions

### Assembly Syntax

![20220310173933](https://raw.githubusercontent.com/zxc2012/image/main/20220316201927.png)

1. no-op: an instruction that does nothing

    ```armasm
    add x0,x0,x0  # Writes to x0 are always ignored
    ```

2. immediates

- RISC-V immediates are "sign extended"(the upper bits are the same as the largest bit)

- for a 12b immediate, Bits 31:12 get the same value as Bit 11

3. Loading and Storing Bytes

- Transfer from Register to Memory: sw/sb

    ![20220317204056](https://raw.githubusercontent.com/zxc2012/image/main/20220317204056.png)
    
    on sb, upper 24 bits are ignored

    ![20220317204139](https://raw.githubusercontent.com/zxc2012/image/main/20220317204139.png)

- Transfer from Memory to Register: lw/lb

    on lb, upper 24 bits are filled by sign-extension

    ![20220317204338](https://raw.githubusercontent.com/zxc2012/image/main/20220317204338.png)

    For e.g.,  s0 = 0x00000180 (all 32 bits)

    ```armasm
    lb s1,1(s0) # s1 = 0x00000001
    lb s2,0(s0) # s2 = 0xFFFFFF80
    sb s2,2(s0) # *(s0) = 0x00800180
    ```

    *常见错误*
    ```armasm
    add x10,x11,4(x12) # 必须先lw再add
    ```
4. branches
- conditional branch
    - branch if equal (beq) or branch if not equal (bne)
    - branch if less than (blt) and branch if greater than or equal (bge)
- unconditional branch
    ```armasm
    j label # pseudo-code 
    jal dst label # Writes PC+4 to dst, set PC=lable
    jalr dst src imm # Writes PC+4 to dst, set PC=src+imm
    jr ra # pseudo-code:ret = jr ra = jalr x0, ra, 0
    ```

### Example 

C Loop Mapped to RISC-V Assembly
```c
int A[20];
int sum = 0;
for (int i=0; i<20; i++)
sum +=  A[i];
```

```armasm
# Assume x8 holds pointer to A
# Assign x10=sum
add x10, x0, x0 # sum=0
add x11, x0, x8 # Copy of A
addi x12,x11, 80 # x12=80 + A
loop:
    lw x13, 0(x11)
    add x10, x10, x13
    addi x11, x11, 4
    blt x11, x12, loop
```

