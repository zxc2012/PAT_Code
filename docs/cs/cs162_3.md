# CS162 Lecture3 --Scheduling

## Basic

Design Objectives
- Response Time: the time from when the job
arrives to the first time it is scheduled($T_{firstrun} -
T_{arrival}$)
- Turnaround time: total time needed to complete a
job($T_{completion} - T_{arrival}$)
- Fairness: give each thread its fair share

Assumptions

- Each job runs for the same amount of time
- All jobs arrive at the same time
- Once started, each job runs to completion
- All jobs only use the CPU (no I/O)
- The run-time of each job is known

## Policies
### FCFS

First-Come-First-Served

**Relax assumption 1: jobs take the same amount of time**

Consider $T_1,T_2,T_3$ sequence of scheduling

- Average response time for (1): 17
- Average response time for (2): 3

![20220531215934](https://raw.githubusercontent.com/zxc2012/image/main/20220531215934.png)

Problem: Short processes stuck behind long processes

### SJF

Shortest Job First->We can choose(2)

**Relax assumption 2: All jobs arrive at the same time**

### SRTF

Shortest Remaining Time First

![20220601202121](https://raw.githubusercontent.com/zxc2012/image/main/20220601202121.png)

**Relax assumption 3: Once started, each job runs to completion**

### RR

Round Robin

- Give out small units of CPU time ("time quantum")
- When quantum expires, preempt, and schedule
    - Round Robin: add to end of the queue
- Each of N processes gets ~1/N of CPU (in window)
    - With quantum length Q ms, process waits at most (N-1)*Q ms to run again
- Downside: More context switches

![20220601210906](https://raw.githubusercontent.com/zxc2012/image/main/20220601210906.png)

**Relax assumption 4: All jobs only use the CPU (no I/O)**

with SRTF, we treat each sub-job as an independent one

![20220601211540](https://raw.githubusercontent.com/zxc2012/image/main/20220601211540.png)

**Relax assumption 5: The run-time of each job is known**

### MLFQ

Multi-Level Feedback Queue

