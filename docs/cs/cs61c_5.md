# CS61C Lecture5 --Parallelism

## Basics

![](https://raw.githubusercontent.com/zxc2012/image/main/20220428200039.png)

### Amdahl’s Law

![](https://raw.githubusercontent.com/zxc2012/image/main/20220428200528.png)

Speedup =$\frac{t_{prev}}{t_{cur}} = \frac{1}{(1-F)+F/S}$

F = Fraction of execution time speed up

S = Scale of improvement

## SIMD

### SIMD Architecture

![](https://raw.githubusercontent.com/zxc2012/image/main/20220505211439.png)

X86 Intrinsics AVX Data Type

![](https://raw.githubusercontent.com/zxc2012/image/main/20220505211808.png)

Intrinsics AVX Code nomenclature [ˈnomənˌkletʃɚ]`name call`

![](https://raw.githubusercontent.com/zxc2012/image/main/20220505212039.png)

![](https://raw.githubusercontent.com/zxc2012/image/main/20220505212550.png)

### Example

#### Matrix Multiply

![](https://raw.githubusercontent.com/zxc2012/image/main/20220505213302.png)

![](https://raw.githubusercontent.com/zxc2012/image/main/20220505214347.png)

```cpp
#include <stdio.h>
// header file for SSE4.2 compiler intrinsics
#include <nmmintrin.h>
// NOTE: vector registers will be represented in
comments as v1 = [ a | b]
// where v1 is a variable of type __m128d and
a,b are doubles
int main(void) {
    // allocate A,B,C aligned on 16-byte boundaries
    double A[4] __attribute__ ((aligned (16)));
    double B[4] __attribute__ ((aligned (16)));
    double C[4] __attribute__ ((aligned (16)));
    int lda = 2;
    int i = 0;
    // declare a couple 128-bit vector variables
    __m128d c1,c2,a,b1,b2;
    /* A = (note column order!)
    1 0
    0 1
    */
    A[0] = 1.0; A[1] = 0.0; A[2] = 0.0; A[3] = 1.0;
    /* B = (note column order!)
    1 3
    2 4
    */
    B[0] = 1.0; B[1] = 2.0; B[2] = 3.0; B[3] = 4.0;
    /* C = (note column order!)
    0 0
    0 0
    */
    C[0] = 0.0; C[1] = 0.0; C[2] = 0.0; C[3] = 0.0;
    // c1 = [c_11 | c_21]
    c1 = _mm_load_pd(C+0*lda);
    // c2 = [c_12 | c_22]
    c2 = _mm_load_pd(C+1*lda);
    for (i = 0; i < 2; i++) {
        /* a =
        i = 0: [a_11 | a_21]
        i = 1: [a_12 | a_22]
        */
        a = _mm_load_pd(A+i*lda);
        /* b1 =
        i = 0: [b_11 | b_11]
        i = 1: [b_21 | b_21]
        */
        b1 = _mm_load1_pd(B+i+0*lda);
        /* b2 =
        i = 0: [b_12 | b_12]
        i = 1: [b_22 | b_22]
        */
        b2 = _mm_load1_pd(B+i+1*lda);
        /* c1 =
        i = 0: [0 + a_11*b_11 | 0 + a_21*b_11]
        i = 1: [c_11 + a_21*b_21 | c_21 + a_22*b_21]
        */
        c1 = _mm_add_pd(c1,_mm_mul_pd(a,b1));
        /* c2 =
        i = 0: [0 + a_11*b_12 | 0 + a_21*b_12]
        i = 1: [c_12 + a_21*b_22 | c_22 + a_22*b_22]
        */
        c2 = _mm_add_pd(c2,_mm_mul_pd(a,b2));
    }
    // store c1,c2 back into C for completion
    _mm_store_pd(C+0*lda,c1);
    _mm_store_pd(C+1*lda,c2);
    // print C
    printf("%g,%g\n%g,%g\n",C[0],C[2],C[1],C[3]);
    return 0;
}
```

#### Loop Unrolling