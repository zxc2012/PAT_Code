# CS162 Lecture2 --Threads and Processes

## Process Management API
pthread: posix(portable operating system interface)
- join(pid) - suspends execution of the calling thread until the target *pid* terminates 
- exit – terminate a process
- fork – copy the current process
    - $>0$: Returned to parent or caller,return value is pid of new child
    - $=0$: Returned to the newly created child process
    - $<0$: error creating,running in original process
- exec – change the program being run by the current process
- wait –  pauses the parent until the child finishes,crashes, or is terminated
    ```c
    int main(int argc, char* argv[]){
        pid_t cpid,tcpid;
        cpid = fork();
        int status;
        pid_t mypid=getpid();
        if (cpid > 0) {               /* Parent Process */
            tcpid = wait(&status);
            printf("%d wait%d(%d)",mypid,tcpid,status);
        } else if (cpid == 0) {      /* Child Process */
            mypid = getpid();
            printf("[%d] child\n", mypid);
            char *myargs[3];
            myargs[0] = strdup("wc");   // program: "wc" (word count)
            myargs[1] = strdup("test.cpp"); // argument: file to count
            myargs[2] = NULL;           // marks end of array
            execvp(myargs[0], myargs);  // runs word count
            printf("this shouldn't print out.\n");
        }
    }
    ```
    output:

    > [8042] child

    > 8041 wait8042(256)
- kill – send a signal (interrupt-like notification) to another process
- signal – system call to send a notification to another process


Main thread creates (forks) collection of sub-threads passing them args to work on, and then *join*s with them, collecting results

![20220120162550](https://raw.githubusercontent.com/zxc2012/image/main/20220120162550.png)

## Race Condition

we need to make threads coordinate with each other to ensure **mutual exclusion** in accessing **critical sections** of code

### Lock

Locks provide two atomic operations

- Lock.acquire() – wait until lock is free; then mark it as busy
- Lock.release() – mark lock as free

Problem: SpinLock consumes cycles while waiting

```cpp
TSL(&address) { //test and set lock 
    result = M[address]; // return result from “address” and
    M[address] = 1; // set value at “address” to 1
    return result;
}
int value = 0; // Free
Acquire() {
    while (TSL(&value)) {}; // spin while busy
}
Release() {
    value = 0; // atomic store
}
```

Better Locks

```cpp
int guard = 0;
int value = FREE;
Acquire() {
    // Short busy-wait time
    while (TSL(guard));
    if (value == BUSY) {
        put thread on wait queue;
        run_new_thread() & guard = 0;
    } else {
        value = BUSY;
        guard = 0;
    }
}
Release() {
    // Short busy-wait time
    while (TSL(guard));
    if anyone on wait queue {
        take thread off wait queue
        Place on ready queue;
    } else {
        value = FREE;
    }
    guard = 0;
}
```

### semaphore

semaphore ['sɛməfɔr]`sema- :signal,phoro:carry,bring`

a semaphore has a non-negative integer value and supports the following two operations:
- P() or down(): atomic operation that waits for semaphore to become positive, then decrements it by 1
- V() or up(): an atomic operation that increments the semaphore by 1

P() stands for probe (to test) and V() stands for “verhogen” (to increment) in Dutch

### Producer-Consumer Problem

- Buffer Empty: The producer needs to first add a message to the shared buffer before the consumer can remove it
- Buffer Full: The producer needs to wait for the consumer to catch up

```cpp
semaphore mutex = 1, empty = N, full = 0;
Producer(item){
    empty.P();
    mutex.acquire();//1,2 注意顺序
    Enqueue(item);
    mutex.release();
    full.V(); //4,5顺序可颠倒
}
Consumer() {
    full.P();
    mutex.acquire();
    item = Dequeue();
    mutex.release();
    empty.V();
    return item;
}
```

### Condition Variables