# CS61C Lecture4 --Cache

## Basic

![](https://raw.githubusercontent.com/zxc2012/image/main/20220414195448.png)

### Principle of Locality

- Temporal Locality (locality in time)

    If a memory location is referenced then it will tend to be referenced again soon

- Spatial Locality (locality in space)

    If a memory location is referenced, the locations with nearby addresses will tend to be referenced soon

### Caching Terminology

- Cache hit

    Cache holds a valid copy of the block, so return the desired data

- Cache miss

    Cache does not have desired block, so fetch from memory and put in empty (invalid) slot

Average Memory Access Time(AMAT) = Hit time + Miss rate × 
Miss penalty

### Cache block replacement policy

- Random Replacement

- Least Recently Used (LRU)

    Replace block we used least recently first in the hopes we will use it again later than all other blocks


## Processor Address Fields

a cache of fixed size (C), Memory is (A) byte-addressed

- Offset: denotes block size: (# = K) Bytes
- Index:  Can’t fit all blocks at once, multiple blocks in memory must map to the same “set” in cache (# = $log_2{(C/K/ N)}$)

    - Fully associative (1 set): 0 Index bits!
    - Direct-mapped (N = 1): max Index bits
    - N-way set-associative: somewhere in-between
    
- Tag: f identifying which memory block is currently in each
cache slot (T = A – I – O)

<table>
<tr><th>type</th><th colspan="3">Fields</th></tr>
<tr><td>Fully Associative</td><td colspan ="2">Tag</td><td>Offset</td></tr>
<tr><td>Direct-mapped</td><td>Tag</td><td>Index</td><td>Offset</td></tr>
<tr><td>N-way set-associative</td><td>Tag</td><td>Index</td><td>Offset</td></tr>
</table>

### Fully Associative Cache

- Total bits

    In a slot:
    - Tag field of address as identifier (Tag bits)
    - Valid bit (1 bit): Whether cache slot was filled in
    - Dirty bit (1 bit if write-back)
    - Any necessary replacement management bits (“LRU bits”)

    Total bits in cache
    = (C/K) × (8×$2^{O}$ + Tag + 1 + 1 + ?) bits

- To check a fully associative cache

    1. Look at ALL cache slots in sequence
    2. If Valid bit is 0, then ignore
    3. If Valid bit is 1 and Tag matches, then return that data

- Example

    Offset – 2 bits, Tag – 4 bits

    ![20220414205040](https://raw.githubusercontent.com/zxc2012/image/main/20220414205356.png)

    ![20220414205845](https://raw.githubusercontent.com/zxc2012/image/main/20220414205845.png)

    Same requests, but reordered

    ![20220414205845](https://raw.githubusercontent.com/zxc2012/image/main/20220414205939.png)

    ![20220414205845](https://raw.githubusercontent.com/zxc2012/image/main/20220414210035.png)

    Original sequence, but double block size

    ![20220414205845](https://raw.githubusercontent.com/zxc2012/image/main/20220414210248.png)

    ![20220414205845](https://raw.githubusercontent.com/zxc2012/image/main/20220414210332.png)

### Direct-Mapped

- Total bits

    Total bits in cache
    = (C/K) × (8×$2^{O}$ + Tag + 1 + 1 + ?) bits