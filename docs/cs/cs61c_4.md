# CS61C Lecture4 --Cache

## Basic

![](https://raw.githubusercontent.com/zxc2012/image/main/20220414195448.png)

### Principle of Locality

- Temporal Locality (locality in time)

    If a memory location is referenced then it will tend to be referenced again soon

- Spatial Locality (locality in space)

    If a memory location is referenced, the locations with nearby addresses will tend to be referenced soon

### Caching Terminology

- Cache hit

    Cache holds a valid copy of the block, so return the desired data

- Cache miss

    Cache does not have desired block, so fetch from memory and put in empty (invalid) slot

Average Memory Access Time(AMAT) = Hit time + Miss rate × 
Miss penalty

### Cache block replacement policy

- Random Replacement

- Least Recently Used (LRU)

    Replace block we used least recently first in the hopes we will use it again later than all other blocks

### Caching Read & Write

we assume the use of separate instruction and data
caches (Icache and Dcache)
- Read from both
- Write only to Dcache (assume no self-modifying code)

Write Hits

- **Write-Through** Policy: Always write data to
cache and to memory (through cache)

- **Write-Back** Policy: Write data only to cache,
then update memory when block is removed

    Dirty bit: Extra bit per cache row that is set if block was written to (is “dirty”) and needs to be written back

Write Miss

- **Write Allocate** policy: when we bring the block
into the cache after a write miss

    Write allocate almost always paired with write-back(Memory is always up-to-date)

- **No Write Allocate** policy: only change main
memory after a write miss
    
    No write allocate typically paired with write-through(Cache is always up-to-date)

## Processor Address Fields

a cache of fixed size (C), Memory is (A) byte-addressed

- Offset: denotes block size: (# = K) Bytes
- Index:  Can’t fit all blocks at once, multiple blocks in memory must map to the same “set” in cache 

    (# = $log_2{(C/K/N)}$)

    - Fully associative (1 set): 0 Index bits!
    - Direct-mapped (N = 1): max Index bits
    - N-way set-associative: somewhere in-between
    
- Tag: f identifying which memory block is currently in each
cache slot (T = A – I – O)

<table>
<tr><th>type</th><th colspan="3">Fields</th></tr>
<tr><td>Fully Associative</td><td colspan ="2">Tag</td><td>Offset</td></tr>
<tr><td>Direct-mapped</td><td>Tag</td><td>Index</td><td>Offset</td></tr>
<tr><td>N-way set-associative</td><td>Tag</td><td>Index</td><td>Offset</td></tr>
</table>

![20220414205040](https://raw.githubusercontent.com/zxc2012/image/main/20220414212245.png)

### Fully Associative Cache

- Total bits

    In a slot:

    - Tag field of address as identifier (Tag bits)
    - Valid bit (1 bit): Whether cache slot was filled in
    - Dirty bit (1 bit if write-back)
    - Any necessary replacement management bits (“LRU bits”)

    Total bits in cache = $(C/K) \times (8 \times 2^{O} + Tag + 1 + 1 + ?)$ bits

- To check a fully associative cache

    1. Look at ALL cache slots in sequence
    2. If Valid bit is 0, then ignore
    3. If Valid bit is 1 and Tag matches, then return that data

- Example

    Offset – 2 bits, Tag – 4 bits

    ![20220414205040](https://raw.githubusercontent.com/zxc2012/image/main/20220414205356.png)

    ![20220414205845](https://raw.githubusercontent.com/zxc2012/image/main/20220414205845.png)

    Same requests, but reordered

    ![20220414205845](https://raw.githubusercontent.com/zxc2012/image/main/20220414205939.png)

    ![20220414205845](https://raw.githubusercontent.com/zxc2012/image/main/20220414210035.png)

    Original sequence, but double block size

    ![20220414205845](https://raw.githubusercontent.com/zxc2012/image/main/20220414210248.png)

    ![20220414205845](https://raw.githubusercontent.com/zxc2012/image/main/20220414210332.png)

### Direct-Mapped

- Total bits

    Total bits in cache = $(C/K) \times (8 \times 2^{O} + Tag + 1 + 1 + ?)$ bits

- Example

    ![20220414211441](https://raw.githubusercontent.com/zxc2012/image/main/20220414211441.png)

    ![20220414211441](https://raw.githubusercontent.com/zxc2012/image/main/20220414212020.png)

    ![20220414212112](https://raw.githubusercontent.com/zxc2012/image/main/20220414212112.png)

### N-way set-associative

Divide $ into sets, each of which consists of N slots

- Memory block maps to a set determined by Index field and is placed in any of the N slots of that set
- Replacement policy applies to every set

Total bits = $2^I$ × N × (8×$2^{O}$ + Tag + 1 + 1 + ?) bits

![20220414212112](https://raw.githubusercontent.com/zxc2012/image/main/20220414212912.png)

Example

![20220414212112](https://raw.githubusercontent.com/zxc2012/image/main/20220414213103.png)

![20220414213153](https://raw.githubusercontent.com/zxc2012/image/main/20220414213153.png)

![20220414213239](https://raw.githubusercontent.com/zxc2012/image/main/20220414213239.png)

## 