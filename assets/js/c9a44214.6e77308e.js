"use strict";(self.webpackChunkChance=self.webpackChunkChance||[]).push([[1054],{5162:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(7294),r=n(6010);const i="tabItem_Ymn6";function l(e){let{children:t,hidden:n,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,l),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>S});var a=n(7462),r=n(7294),i=n(6010),l=n(2466),s=n(6550),u=n(1980),o=n(7392),c=n(12);function p(e){return function(e){var t;return(null==(t=r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:t.filter(Boolean))??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function m(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,o.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function d(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,s.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,u._X)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(a.location.search);t.set(i,e),a.replace({...a.location,search:t.toString()})}),[i,a])]}function k(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=m(e),[l,s]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[u,o]=h({queryString:n,groupId:a}),[p,k]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,i]=(0,c.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),f=(()=>{const e=u??p;return d({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{f&&s(f)}),[f]);return{selectedValue:l,selectValue:(0,r.useCallback)((e=>{if(!d({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);s(e),o(e),k(e)}),[o,k,i]),tabValues:i}}var f=n(2389);const b="tabList__CuJ",g="tabItem_LNqP";function v(e){let{className:t,block:n,selectedValue:s,selectValue:u,tabValues:o}=e;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,l.o5)(),m=e=>{const t=e.currentTarget,n=c.indexOf(t),a=o[n].value;a!==s&&(p(t),u(a))},d=e=>{var t;let n=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}null==(t=n)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},o.map((e=>{let{value:t,label:n,attributes:l}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>c.push(e),onKeyDown:d,onClick:m},l,{className:(0,i.Z)("tabs__item",g,null==l?void 0:l.className,{"tabs__item--active":s===t})}),n??t)})))}function y(e){let{lazy:t,children:n,selectedValue:a}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},i.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function w(e){const t=k(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",b)},r.createElement(v,(0,a.Z)({},e,t)),r.createElement(y,(0,a.Z)({},e,t)))}function S(e){const t=(0,f.Z)();return r.createElement(w,(0,a.Z)({key:String(t)},e))}},3264:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>u,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905)),i=(n(1839),n(4866)),l=n(5162);const s={},u="4 Data Structure",o={unversionedId:"Algorithms/4",id:"Algorithms/4",title:"4 Data Structure",description:"Array",source:"@site/docs/Algorithms/4.md",sourceDirName:"Algorithms",slug:"/Algorithms/4",permalink:"/docs/Algorithms/4",draft:!1,editUrl:"https://github.com/zxc2012/zxc2012.github.io/tree/master/docs/Algorithms/4.md",tags:[],version:"current",frontMatter:{},sidebar:"Algorithms",previous:{title:"3 Basic Strategy",permalink:"/docs/Algorithms/3"},next:{title:"5 Searching summary",permalink:"/docs/Algorithms/5"}},c={},p=[{value:"Array",id:"array",level:2},{value:"LinkedList",id:"linkedlist",level:2},{value:"Stack",id:"stack",level:2},{value:"Monotonic Stack",id:"monotonic-stack",level:3},{value:"Deque",id:"deque",level:2}],m={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"4-data-structure"},"4 Data Structure"),(0,r.kt)("h2",{id:"array"},"Array"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u6570\u7ec4\u8d8a\u754c"),(0,r.kt)("li",{parentName:"ul"},"\u6570\u7ec4\u662f\u5426\u53ef\u4ee5\u91cd\u590d,\u91cd\u590d\u7684\u5904\u7406")),(0,r.kt)("h2",{id:"linkedlist"},"LinkedList"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"\u6613\u9519\u70b9:\u6bcf\u4e00\u6b65p->next\u68c0\u67e5p!=NULL")),(0,r.kt)("h2",{id:"stack"},"Stack"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Basic Calculator")),(0,r.kt)("p",null,"Implement a basic calculator to evaluate a simple expression string."),(0,r.kt)("p",null,"The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces . The integer division should truncate toward zero."),(0,r.kt)("p",null,"You may assume that the given expression is always valid. All intermediate results will be in the range of ","[-2147483648, 2147483647]"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"stack",mdxType:"TabItem"},(0,r.kt)("p",null,"if there are no brackets, we could evaluate easily"),(0,r.kt)("p",null,"if there are brackets, we could see each part = nonbracket + evaluate(bracket), but nonbracket should be store in a stack"),(0,r.kt)("p",null,"Problems: evaluate(bracket) could be -3, so the new expression could contain 3*-3, 3+-3, 3--3. We need to handle those."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int calculate(string &s) {\n    stack<string> nonbracket;\n    string curStr; \n    for(auto p: s){\n        if(p=='('){\n            nonbracket.push(curStr);\n            curStr = \"\";\n        }\n        else if(p==')'){\n            curStr = to_string(evaluate(curStr));\n            curStr = nonbracket.top() + curStr;\n            nonbracket.pop();\n        }\n        else if(p!=' ') curStr +=p;\n    }\n    return evaluate(curStr);\n}\nlong long evaluate(string input){\n    int i =0, j =0;\n    long long base = 0, temp = 0;\n    input = '+' + input;\n    while(i<input.size()){\n        if(input[i]=='+'||input[i]=='-'){\n            base += temp;\n            j = i+1;\n            if(input[j]=='-')++j;\n            while(isdigit(input[j]))++j;\n            temp = stoll(input.substr(i+1,j-1-i));\n            temp = input[i]=='+'?temp: -temp;\n            i = j;\n        }\n        else if(input[i]=='*'||input[i]=='/'){\n            j = i+1;\n            if(input[j]=='-')++j;\n            while(isdigit(input[j]))++j;\n            if(input[i]=='*') temp *= stoll(input.substr(i+1,j-1-i));\n            else temp /= stoll(input.substr(i+1,j-1-i));\n            i = j;\n        }\n    }\n    return base + temp;\n}\n"))),(0,r.kt)(l.Z,{value:"recursion",mdxType:"TabItem"},(0,r.kt)("p",null,"for each character, if not empty space, make sure you are handling digits and is an operator before go to next step:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"if last character ')', break "),(0,r.kt)("li",{parentName:"ul"},"'(': recursion(i+1)"),(0,r.kt)("li",{parentName:"ul"},"digit: transform from string to long long, i becomes operator when it is done")),(0,r.kt)("p",null,"as we always start from digits, we will not handle operator every loop, and we could record last operator(or character)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int calculate(string &s) {\n    int i =0;\n    return calHelper(s,i);\n}\nint calHelper(string &s,int &i){\n    char op = '+';\n    long long base=0, temp = 0;\n    int n = s.size();\n    while(i<n&&op!=')'){\n        if(s[i]!=' '){\n            long long num = 0;\n            if(s[i] == '(')num = calHelper(s,++i);\n            else{\n                while(i<n&&isdigit(s[i])){\n                    num = num*10 + s[i] - '0';\n                    ++i;\n                } \n            }\n            if(op=='+'){\n                base +=temp;\n                temp = num;\n            }\n            else if(op == '-'){\n                base +=temp;\n                temp = -num;\n            }\n            else if(op == '*') temp *= num;\n            else if(op == '/') temp /= num;\n            if(i<n) op = s[i];\n        }\n        ++i;\n    }\n    return base + temp;\n}\n")))),(0,r.kt)("h3",{id:"monotonic-stack"},"Monotonic Stack"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Mono-decreasing(pop smaller elements) stack keeps the result as greater as possible"),(0,r.kt)("li",{parentName:"ul"},"Mono-increasing stack keeps the result as smaller as possible ")),(0,r.kt)("h2",{id:"deque"},"Deque"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Sliding Window Maximum")),(0,r.kt)("p",null,"You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n    deque<int> dq;\n    vector<int> ans;\n    for(int i=0;i<nums.size();++i){\n        while(!dq.empty()&&dq.front()<nums[i])dq.pop_front();\n        dq.push_front(nums[i]);\n        if(i-k>=0&&!dq.empty()&&dq.back()==nums[i-k])dq.pop_back();\n        if(i>=k-1) ans.push_back(dq.back());\n    }\n    return ans;\n}\n")))}d.isMDXComponent=!0}}]);