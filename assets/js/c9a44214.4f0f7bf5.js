"use strict";(self.webpackChunkChance=self.webpackChunkChance||[]).push([[1054],{5162:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294),i=n(6010);const l="tabItem_Ymn6";function r(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(l,r),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>m});var a=n(7462),i=n(7294),l=n(6010),r=n(2389),s=n(7392),o=n(7094),u=n(2466);const p="tabList__CuJ",c="tabItem_LNqP";function d(e){var t;const{lazy:n,block:r,defaultValue:d,values:m,groupId:h,className:k}=e,g=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),b=m??g.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),v=(0,s.l)(b,((e,t)=>e.value===t.value));if(v.length>0)throw new Error(`Docusaurus error: Duplicate values "${v.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const f=null===d?d:d??(null==(t=g.find((e=>e.props.default)))?void 0:t.props.value)??g[0].props.value;if(null!==f&&!b.some((e=>e.value===f)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${f}" but none of its children has the corresponding value. Available values are: ${b.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:N,setTabGroupChoices:y}=(0,o.U)(),[w,x]=(0,i.useState)(f),S=[],{blockElementScrollPositionUntilNextRender:T}=(0,u.o5)();if(null!=h){const e=N[h];null!=e&&e!==w&&b.some((t=>t.value===e))&&x(e)}const A=e=>{const t=e.currentTarget,n=S.indexOf(t),a=b[n].value;a!==w&&(T(t),x(a),null!=h&&y(h,String(a)))},j=e=>{var t;let n=null;switch(e.key){case"Enter":A(e);break;case"ArrowRight":{const t=S.indexOf(e.currentTarget)+1;n=S[t]??S[0];break}case"ArrowLeft":{const t=S.indexOf(e.currentTarget)-1;n=S[t]??S[S.length-1];break}}null==(t=n)||t.focus()};return i.createElement("div",{className:(0,l.Z)("tabs-container",p)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":r},k)},b.map((e=>{let{value:t,label:n,attributes:r}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:w===t?0:-1,"aria-selected":w===t,key:t,ref:e=>S.push(e),onKeyDown:j,onClick:A},r,{className:(0,l.Z)("tabs__item",c,null==r?void 0:r.className,{"tabs__item--active":w===t})}),n??t)}))),n?(0,i.cloneElement)(g.filter((e=>e.props.value===w))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==w})))))}function m(e){const t=(0,r.Z)();return i.createElement(d,(0,a.Z)({key:String(t)},e))}},3264:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>u,toc:()=>c});var a=n(7462),i=(n(7294),n(3905)),l=(n(1839),n(5488)),r=n(5162);const s={},o="4 Data Structure",u={unversionedId:"Algorithms/4",id:"Algorithms/4",title:"4 Data Structure",description:"Array",source:"@site/docs/Algorithms/4.md",sourceDirName:"Algorithms",slug:"/Algorithms/4",permalink:"/docs/Algorithms/4",draft:!1,editUrl:"https://github.com/zxc2012/zxc2012.github.io/tree/master/docs/Algorithms/4.md",tags:[],version:"current",frontMatter:{},sidebar:"Algorithms",previous:{title:"3 Basic Strategy",permalink:"/docs/Algorithms/3"},next:{title:"5 Searching summary",permalink:"/docs/Algorithms/5"}},p={},c=[{value:"Array",id:"array",level:2},{value:"LinkedList",id:"linkedlist",level:2},{value:"Stack",id:"stack",level:2},{value:"Monotonic Stack",id:"monotonic-stack",level:3},{value:"Deque",id:"deque",level:2},{value:"Hashmap",id:"hashmap",level:2},{value:"Separate Chaining Data Indexed Array",id:"separate-chaining-data-indexed-array",level:3},{value:"Open Addressing",id:"open-addressing",level:3}],d={toc:c};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"4-data-structure"},"4 Data Structure"),(0,i.kt)("h2",{id:"array"},"Array"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u6570\u7ec4\u8d8a\u754c"),(0,i.kt)("li",{parentName:"ul"},"\u6570\u7ec4\u662f\u5426\u53ef\u4ee5\u91cd\u590d,\u91cd\u590d\u7684\u5904\u7406")),(0,i.kt)("h2",{id:"linkedlist"},"LinkedList"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"\u6613\u9519\u70b9:\u6bcf\u4e00\u6b65p->next\u68c0\u67e5p!=NULL")),(0,i.kt)("h2",{id:"stack"},"Stack"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Basic Calculator")),(0,i.kt)("p",null,"Implement a basic calculator to evaluate a simple expression string."),(0,i.kt)("p",null,"The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces . The integer division should truncate toward zero."),(0,i.kt)("p",null,"You may assume that the given expression is always valid. All intermediate results will be in the range of ","[-2147483648, 2147483647]"),(0,i.kt)(l.Z,{mdxType:"Tabs"},(0,i.kt)(r.Z,{value:"stack",mdxType:"TabItem"},(0,i.kt)("p",null,"if there are no brackets, we could evaluate easily"),(0,i.kt)("p",null,"if there are brackets, we could see each part = nonbracket + evaluate(bracket), but nonbracket should be store in a stack"),(0,i.kt)("p",null,"Problems: evaluate(bracket) could be -3, so the new expression could contain 3*-3, 3+-3, 3--3. We need to handle those."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"int calculate(string &s) {\n    stack<string> nonbracket;\n    string curStr; \n    for(auto p: s){\n        if(p=='('){\n            nonbracket.push(curStr);\n            curStr = \"\";\n        }\n        else if(p==')'){\n            curStr = to_string(evaluate(curStr));\n            curStr = nonbracket.top() + curStr;\n            nonbracket.pop();\n        }\n        else if(p!=' ') curStr +=p;\n    }\n    return evaluate(curStr);\n}\nlong long evaluate(string input){\n    int i =0, j =0;\n    long long base = 0, temp = 0;\n    input = '+' + input;\n    while(i<input.size()){\n        if(input[i]=='+'||input[i]=='-'){\n            base += temp;\n            j = i+1;\n            if(input[j]=='-')++j;\n            while(isdigit(input[j]))++j;\n            temp = stoll(input.substr(i+1,j-1-i));\n            temp = input[i]=='+'?temp: -temp;\n            i = j;\n        }\n        else if(input[i]=='*'||input[i]=='/'){\n            j = i+1;\n            if(input[j]=='-')++j;\n            while(isdigit(input[j]))++j;\n            if(input[i]=='*') temp *= stoll(input.substr(i+1,j-1-i));\n            else temp /= stoll(input.substr(i+1,j-1-i));\n            i = j;\n        }\n    }\n    return base + temp;\n}\n"))),(0,i.kt)(r.Z,{value:"recursion",mdxType:"TabItem"},(0,i.kt)("p",null,"for each character, if not empty space, make sure you are handling digits and is an operator before go to next step:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"if last character ')', break "),(0,i.kt)("li",{parentName:"ul"},"'(': recursion(i+1)"),(0,i.kt)("li",{parentName:"ul"},"digit: transform from string to long long, i becomes operator when it is done")),(0,i.kt)("p",null,"as we always start from digits, we will not handle operator every loop, and we could record last operator(or character)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"int calculate(string &s) {\n    int i =0;\n    return calHelper(s,i);\n}\nint calHelper(string &s,int &i){\n    char op = '+';\n    long long base=0, temp = 0;\n    int n = s.size();\n    while(i<n&&op!=')'){\n        if(s[i]!=' '){\n            long long num = 0;\n            if(s[i] == '(')num = calHelper(s,++i);\n            else{\n                while(i<n&&isdigit(s[i])){\n                    num = num*10 + s[i] - '0';\n                    ++i;\n                } \n            }\n            if(op=='+'){\n                base +=temp;\n                temp = num;\n            }\n            else if(op == '-'){\n                base +=temp;\n                temp = -num;\n            }\n            else if(op == '*') temp *= num;\n            else if(op == '/') temp /= num;\n            if(i<n) op = s[i];\n        }\n        ++i;\n    }\n    return base + temp;\n}\n")))),(0,i.kt)("h3",{id:"monotonic-stack"},"Monotonic Stack"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Mono-decreasing(pop smaller elements) stack keeps the result as greater as possible"),(0,i.kt)("li",{parentName:"ul"},"Mono-increasing stack keeps the result as smaller as possible ")),(0,i.kt)("h2",{id:"deque"},"Deque"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Sliding Window Maximum")),(0,i.kt)("p",null,"You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n    deque<int> dq;\n    vector<int> ans;\n    for(int i=0;i<nums.size();++i){\n        while(!dq.empty()&&dq.front()<nums[i])dq.pop_front();\n        dq.push_front(nums[i]);\n        if(i-k>=0&&!dq.empty()&&dq.back()==nums[i-k])dq.pop_back();\n        if(i>=k-1) ans.push_back(dq.back());\n    }\n    return ans;\n}\n")),(0,i.kt)("h2",{id:"hashmap"},"Hashmap"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Implement"),(0,i.kt)("th",{parentName:"tr",align:null},"contains(x)"),(0,i.kt)("th",{parentName:"tr",align:null},"add(x)"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Bushy BSTs"),(0,i.kt)("td",{parentName:"tr",align:null},"\u0398(log N)"),(0,i.kt)("td",{parentName:"tr",align:null},"\u0398(log N)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Separate Chaining Hash Table With No Resizing"),(0,i.kt)("td",{parentName:"tr",align:null},"\u0398(N)"),(0,i.kt)("td",{parentName:"tr",align:null},"\u0398(N)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"\u2026 With Resizing"),(0,i.kt)("td",{parentName:"tr",align:null},"\u0398(1)"),(0,i.kt)("td",{parentName:"tr",align:null},"\u0398(1)")))),(0,i.kt)("h3",{id:"separate-chaining-data-indexed-array"},"Separate Chaining Data Indexed Array"),(0,i.kt)("p",null,"Data is converted into a hash code. The hash code is then reduced to a valid index."),(0,i.kt)("p",null,"Java\u2019s hashCode() function for Strings"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public int hashCode() {// From Left to right: High to Low\n    int h = cachedHashValue;\n    if (h == 0 && this.length() > 0) {\n        for (int i = 0; i < this.length(); i++) {\n            h = 31 * h + this.charAt(i);\n        }\n        cachedHashValue = h;\n    }\n    return h;\n}\n")),(0,i.kt)("p",null,"31: the hashCode base should be a small ",(0,i.kt)("strong",{parentName:"p"},"prime")," to avoid overflow"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20221120134556.png",alt:"20221120134556"})),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20221120135107.png",alt:"20221120135107"})),(0,i.kt)("p",null,"suppose the number of buckets: M, number of items: N"),(0,i.kt)("p",null,"then complexities of contains and add are O(Q = N/M) "),(0,i.kt)("p",null,"To make them O(1), strategy: When N/M is \u2265 1.5, double M"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"bool contains(int x, vector<list<int>>& hash_table){\n    int n = hash_table.size();\n    int index = (x%n + n)%n;\n    list<int>& slot = hash_table[index]; \n    return find(slot.begin(),slot.end(),x)!=slot.end();\n}\nbool add(int x,vector<list<int>>& hash_table){\n    int n = hash_table.size();\n    int index = (x%n + n)%n;\n    hash_table[index].push_back(x);\n}\n")),(0,i.kt)("h3",{id:"open-addressing"},"Open Addressing"),(0,i.kt)("p",null,"An alternate way to handle collisions is to use open addressing"),(0,i.kt)("p",null,"If target bucket is already occupied, use a different bucket"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Linear probing",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Use next address, and if already occupied, just keep scanning one by one."))),(0,i.kt)("li",{parentName:"ul"},"Quadratic probing",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Use next address, and if already occupied, try looking 4 ahead, then 9 ahead, then 16 ahead, ...")))))}m.isMDXComponent=!0}}]);