"use strict";(self.webpackChunkChance=self.webpackChunkChance||[]).push([[1054],{5162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(7294),l=n(6010);const r="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(r,i),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>d});var a=n(7462),l=n(7294),r=n(6010),i=n(2389),s=n(7392),o=n(7094),u=n(2466);const c="tabList__CuJ",p="tabItem_LNqP";function m(e){var t;const{lazy:n,block:i,defaultValue:m,values:d,groupId:h,className:k}=e,b=l.Children.map(e.children,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=d??b.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),v=(0,s.l)(g,((e,t)=>e.value===t.value));if(v.length>0)throw new Error(`Docusaurus error: Duplicate values "${v.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const f=null===m?m:m??(null==(t=b.find((e=>e.props.default)))?void 0:t.props.value)??b[0].props.value;if(null!==f&&!g.some((e=>e.value===f)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${f}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:w}=(0,o.U)(),[N,S]=(0,l.useState)(f),T=[],{blockElementScrollPositionUntilNextRender:j}=(0,u.o5)();if(null!=h){const e=y[h];null!=e&&e!==N&&g.some((t=>t.value===e))&&S(e)}const x=e=>{const t=e.currentTarget,n=T.indexOf(t),a=g[n].value;a!==N&&(j(t),S(a),null!=h&&w(h,String(a)))},A=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=T.indexOf(e.currentTarget)+1;n=T[t]??T[0];break}case"ArrowLeft":{const t=T.indexOf(e.currentTarget)-1;n=T[t]??T[T.length-1];break}}null==(t=n)||t.focus()};return l.createElement("div",{className:(0,r.Z)("tabs-container",c)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":i},k)},g.map((e=>{let{value:t,label:n,attributes:i}=e;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,key:t,ref:e=>T.push(e),onKeyDown:A,onFocus:x,onClick:x},i,{className:(0,r.Z)("tabs__item",p,null==i?void 0:i.className,{"tabs__item--active":N===t})}),n??t)}))),n?(0,l.cloneElement)(b.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},b.map(((e,t)=>(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==N})))))}function d(e){const t=(0,i.Z)();return l.createElement(m,(0,a.Z)({key:String(t)},e))}},3264:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>u,toc:()=>p});var a=n(7462),l=(n(7294),n(3905)),r=(n(1839),n(5488)),i=n(5162);const s={},o="4 Data Structure",u={unversionedId:"Algorithms/4",id:"Algorithms/4",title:"4 Data Structure",description:"Array",source:"@site/docs/Algorithms/4.md",sourceDirName:"Algorithms",slug:"/Algorithms/4",permalink:"/docs/Algorithms/4",draft:!1,editUrl:"https://github.com/zxc2012/zxc2012.github.io/tree/master/docs/Algorithms/4.md",tags:[],version:"current",frontMatter:{},sidebar:"Algorithms",previous:{title:"3 Basic Strategy",permalink:"/docs/Algorithms/3"},next:{title:"5 Searching summary",permalink:"/docs/Algorithms/5"}},c={},p=[{value:"Array",id:"array",level:2},{value:"LinkedList",id:"linkedlist",level:2},{value:"Stack",id:"stack",level:2},{value:"Monotonic Stack",id:"monotonic-stack",level:3},{value:"Deque",id:"deque",level:2}],m={toc:p};function d(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"4-data-structure"},"4 Data Structure"),(0,l.kt)("h2",{id:"array"},"Array"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u6570\u7ec4\u8d8a\u754c"),(0,l.kt)("li",{parentName:"ul"},"\u6570\u7ec4\u662f\u5426\u53ef\u4ee5\u91cd\u590d,\u91cd\u590d\u7684\u5904\u7406")),(0,l.kt)("h2",{id:"linkedlist"},"LinkedList"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"\u6613\u9519\u70b9:\u6bcf\u4e00\u6b65p->next\u68c0\u67e5p!=NULL")),(0,l.kt)("h2",{id:"stack"},"Stack"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Basic Calculator")),(0,l.kt)("p",null,"Implement a basic calculator to evaluate a simple expression string."),(0,l.kt)("p",null,"The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces . The integer division should truncate toward zero."),(0,l.kt)("p",null,"You may assume that the given expression is always valid. All intermediate results will be in the range of ","[-2147483648, 2147483647]"),(0,l.kt)(r.Z,{mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"stack",mdxType:"TabItem"},(0,l.kt)("p",null,"if there are no brackets, we could evaluate easily"),(0,l.kt)("p",null,"if there are brackets, we could see each part = nonbracket + evaluate(bracket), but nonbracket should be store in a stack"),(0,l.kt)("p",null,"Problems: evaluate(bracket) could be -3, so the new expression could contain 3*-3, 3+-3, 3--3. We need to handle those."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"int calculate(string &s) {\n    stack<string> nonbracket;\n    string curStr; \n    for(auto p: s){\n        if(p=='('){\n            nonbracket.push(curStr);\n            curStr = \"\";\n        }\n        else if(p==')'){\n            curStr = to_string(evaluate(curStr));\n            curStr = nonbracket.top() + curStr;\n            nonbracket.pop();\n        }\n        else if(p!=' ') curStr +=p;\n    }\n    return evaluate(curStr);\n}\nlong long evaluate(string input){\n    int i =0, j =0;\n    long long base = 0, temp = 0;\n    input = '+' + input;\n    while(i<input.size()){\n        if(input[i]=='+'||input[i]=='-'){\n            base += temp;\n            j = i+1;\n            if(input[j]=='-')++j;\n            while(isdigit(input[j]))++j;\n            temp = stoll(input.substr(i+1,j-1-i));\n            temp = input[i]=='+'?temp: -temp;\n            i = j;\n        }\n        else if(input[i]=='*'||input[i]=='/'){\n            j = i+1;\n            if(input[j]=='-')++j;\n            while(isdigit(input[j]))++j;\n            if(input[i]=='*') temp *= stoll(input.substr(i+1,j-1-i));\n            else temp /= stoll(input.substr(i+1,j-1-i));\n            i = j;\n        }\n    }\n    return base + temp;\n}\n"))),(0,l.kt)(i.Z,{value:"recursion",mdxType:"TabItem"},(0,l.kt)("p",null,"for each character, if not empty space, make sure you are handling digits and is an operator before go to next step:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"if last character ')', break "),(0,l.kt)("li",{parentName:"ul"},"'(': recursion(i+1)"),(0,l.kt)("li",{parentName:"ul"},"digit: transform from string to long long, i becomes operator when it is done")),(0,l.kt)("p",null,"as we always start from digits, we will not handle operator every loop, and we could record last operator(or character)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"int calculate(string &s) {\n    int i =0;\n    return calHelper(s,i);\n}\nint calHelper(string &s,int &i){\n    char op = '+';\n    long long base=0, temp = 0;\n    int n = s.size();\n    while(i<n&&op!=')'){\n        if(s[i]!=' '){\n            long long num = 0;\n            if(s[i] == '(')num = calHelper(s,++i);\n            else{\n                while(i<n&&isdigit(s[i])){\n                    num = num*10 + s[i] - '0';\n                    ++i;\n                } \n            }\n            if(op=='+'){\n                base +=temp;\n                temp = num;\n            }\n            else if(op == '-'){\n                base +=temp;\n                temp = -num;\n            }\n            else if(op == '*') temp *= num;\n            else if(op == '/') temp /= num;\n            if(i<n) op = s[i];\n        }\n        ++i;\n    }\n    return base + temp;\n}\n")))),(0,l.kt)("h3",{id:"monotonic-stack"},"Monotonic Stack"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Mono-decreasing(pop smaller elements) stack keeps the result as greater as possible"),(0,l.kt)("li",{parentName:"ul"},"Mono-increasing stack keeps the result as smaller as possible ")),(0,l.kt)("h2",{id:"deque"},"Deque"))}d.isMDXComponent=!0}}]);