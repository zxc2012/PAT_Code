"use strict";(self.webpackChunkChance=self.webpackChunkChance||[]).push([[6834],{1918:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));n(1839);const r={},l="CS162 Lecture2 --Synchronization",o={unversionedId:"cs/cs162_2",id:"cs/cs162_2",title:"CS162 Lecture2 --Synchronization",description:"Race Condition",source:"@site/docs/cs/cs162_2.md",sourceDirName:"cs",slug:"/cs/cs162_2",permalink:"/docs/cs/cs162_2",draft:!1,editUrl:"https://github.com/zxc2012/zxc2012.github.io/tree/master/docs/cs/cs162_2.md",tags:[],version:"current",frontMatter:{},sidebar:"cs",previous:{title:"CS162 Lecture1 --Operating System Overview",permalink:"/docs/cs/cs162_1"},next:{title:"CS162 Lecture3 --Scheduling",permalink:"/docs/cs/cs162_3"}},u={},s=[{value:"Race Condition",id:"race-condition",level:2},{value:"Lock",id:"lock",level:3},{value:"semaphore",id:"semaphore",level:3},{value:"Producer-Consumer Problem",id:"producer-consumer-problem",level:3},{value:"Monitors",id:"monitors",level:3},{value:"More Problems",id:"more-problems",level:2},{value:"The Dining Philosopher",id:"the-dining-philosopher",level:3}],c={toc:s};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"cs162-lecture2---synchronization"},"CS162 Lecture2 --Synchronization"),(0,i.kt)("h2",{id:"race-condition"},"Race Condition"),(0,i.kt)("p",null,"we need to make threads coordinate with each other to ensure ",(0,i.kt)("strong",{parentName:"p"},"mutual exclusion")," in accessing ",(0,i.kt)("strong",{parentName:"p"},"critical sections")," of code"),(0,i.kt)("h3",{id:"lock"},"Lock"),(0,i.kt)("p",null,"Locks provide two atomic operations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Lock.acquire() \u2013 wait until lock is free; then mark it as busy"),(0,i.kt)("li",{parentName:"ul"},"Lock.release() \u2013 mark lock as free")),(0,i.kt)("p",null,"Problem: SpinLock consumes cycles while waiting"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"TSL(&address) { //test and set lock \n    result = M[address]; // return result from \u201caddress\u201d and\n    M[address] = 1; // set value at \u201caddress\u201d to 1\n    return result;\n}\nint value = 0; // Free\nAcquire() {\n    while (TSL(&value)) {}; // spin while busy\n}\nRelease() {\n    value = 0; // atomic store\n}\n")),(0,i.kt)("p",null,"Better Locks"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"int guard = 0;\nint value = FREE;\nAcquire() {\n    // Short busy-wait time\n    while (TSL(guard));\n    if (value == BUSY) {\n        put thread on wait queue;\n        run_new_thread() & guard = 0;\n    } else {\n        value = BUSY;\n        guard = 0;\n    }\n}\nRelease() {\n    // Short busy-wait time\n    while (TSL(guard));\n    if anyone on wait queue {\n        take thread off wait queue\n        Place on ready queue;\n    } else {\n        value = FREE;\n    }\n    guard = 0;\n}\n")),(0,i.kt)("h3",{id:"semaphore"},"semaphore"),(0,i.kt)("p",null,"semaphore ","['s\u025bm\u0259f\u0254r]",(0,i.kt)("inlineCode",{parentName:"p"},"sema- :signal,phoro:carry,bring")),(0,i.kt)("p",null,"a semaphore has a non-negative integer value and supports the following two operations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"P() or down(): atomic operation that waits for semaphore to become positive, then decrements it by 1"),(0,i.kt)("li",{parentName:"ul"},"V() or up(): an atomic operation that increments the semaphore by 1")),(0,i.kt)("p",null,"P() stands for probe (to test) and V() stands for \u201cverhogen\u201d (to increment) in Dutch"),(0,i.kt)("h3",{id:"producer-consumer-problem"},"Producer-Consumer Problem"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Buffer Empty: The producer needs to first add a message to the shared buffer before the consumer can remove it"),(0,i.kt)("li",{parentName:"ul"},"Buffer Full: The producer needs to wait for the consumer to catch up")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"semaphore mutex = 1, empty = N, full = 0;\nProducer(item){\n    empty.P();\n    mutex.acquire();//1,2 \u6ce8\u610f\u987a\u5e8f\n    Enqueue(item);\n    mutex.release();\n    full.V(); //4,5\u987a\u5e8f\u53ef\u98a0\u5012\n}\nConsumer() {\n    full.P();\n    mutex.acquire();\n    item = Dequeue();\n    mutex.release();\n    empty.V();\n    return item;\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"wait->yield->schedule"),(0,i.kt)("li",{parentName:"ul"},"interrupt->schedule")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220531174332.png",alt:"20220531174332"})),(0,i.kt)("h3",{id:"monitors"},"Monitors"),(0,i.kt)("p",null,"Monitor"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Encapsulation",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Local data variables are accessible only via the monitor\u2019s entry methods"))),(0,i.kt)("li",{parentName:"ul"},"Mutual exclusion",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"only one thread can be active in a monitor at any time"),(0,i.kt)("li",{parentName:"ul"},"every method starts with lock and end with unlock")))),(0,i.kt)("p",null,"Condition Variables"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"condition.wait(): a thread exits the monitor, waits for the ",(0,i.kt)("em",{parentName:"li"},"condition")," variable to hold, and enters the monitor again when it does"),(0,i.kt)("li",{parentName:"ul"},"condition.signal(): signals (wakes up) a waiting thread on the ",(0,i.kt)("em",{parentName:"li"},"condition")," variable, so that it can try to enter the monitor"),(0,i.kt)("li",{parentName:"ul"},"condition.broadcast(): signals (wakes up) all waiting threads on the ",(0,i.kt)("em",{parentName:"li"},"condition")," variable, so that they can all try to enter the monitor")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"mutex lock = unlocked;\nCondition full,empty;\nProducer(item){\n    lock.acquire();\n    if(buffer_full)full.wait();//wait when buffer is full\n    Enqueue(item);\n    empty.signal();\n    lock.release();\n}\nConsumer() {\n    lock.acquire();\n    if(buffer_empty)empty.wait();//wait when buffer is empty\n    item = Dequeue();\n    full.signal();\n    lock.release();\n    return item;\n}\n")),(0,i.kt)("p",null,"The Producer is running in the monitor.It adds a message to an empty shared buffer,signals a waiting Consumer thread, waking it up. At this time, the Producer and Consumer cannot both run inside the monitor."),(0,i.kt)("p",null,"(1)Hoare Semantics"),(0,i.kt)("p",null,"The signaled thread, B, enters the monitor immediately,then back to A(The signaling thread)"),(0,i.kt)("p",null,"When a thread call signal():"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It releases the lock and the OS context-switches to the waiter, which acquires the\nlock immediately"),(0,i.kt)("li",{parentName:"ul"},"When waiter releases lock, the OS switches back to signaler")),(0,i.kt)("p",null,"(2)",(0,i.kt)("strong",{parentName:"p"},"Mesa Semantics")),(0,i.kt)("p",null,"The signaled thread is awakened,it will have to compete against all other threads for the monitor lock."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Problem previously"),": "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When a thread is woken up by signal(), it is simply marked as eligible to run. "),(0,i.kt)("li",{parentName:"ul"},'Another thread could be scheduled and "sneak in" make the condition it\u2019s\nwaiting for no longer true.')),(0,i.kt)("p",null,"Solution: if->while"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"mutex lock = unlocked;\nCondition full,empty;\nProducer(item){\n    lock.acquire();\n    while(buffer_full)full.wait();//wait when buffer is full\n    Enqueue(item);\n    empty.signal();\n    lock.release();\n}\nConsumer() {\n    lock.acquire();\n    while(buffer_empty)empty.wait();//wait when buffer is empty\n    item = Dequeue();\n    full.signal();\n    lock.release();\n    return item;\n}\n")),(0,i.kt)("h2",{id:"more-problems"},"More Problems"),(0,i.kt)("h3",{id:"the-dining-philosopher"},"The Dining Philosopher"),(0,i.kt)("p",null,"Five Philosopher sit at a table"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220520215436.png",alt:"20220520215436"})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def philosopher(int i):\n    while true:\n        think()\n        Pickup left fork\n        Pickup right fork\n        eat()\n        Put down left fork\n        Put down right fork\n")),(0,i.kt)("p",null,"DeadLock"),(0,i.kt)("p",null,"It may happen that all five philosophers take their left fork at the same time, and then try to take\ntheir right fork, which is taken by a neighbouring philosopher"),(0,i.kt)("p",null,"Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"semaphore forks[5]= {1,1,1,1,1}\ndef pickup_fork(int i):\n    forks[i].down()\ndef putdown_fork(int i):\n    forks[i].up()\n\ndef pickup_forks(int i):\n    if i == 4:\n        pickup_fork((i+1) modulo 5)\n        pickup_fork(i)\n    else:\n        pickup_fork(i)\n        pickup_fork((i+1) modulo 5)\ndef putdown_forks(int i):\n    putdown_fork(i)\n    putdown_fork((i+1) modulo 5)\n")))}p.isMDXComponent=!0}}]);