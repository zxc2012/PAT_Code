"use strict";(self.webpackChunkChance=self.webpackChunkChance||[]).push([[9284],{2861:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>p,contentTitle:()=>r,default:()=>o,frontMatter:()=>s,metadata:()=>m,toc:()=>i});var n=a(7462),l=(a(7294),a(3905));a(1839);const s={},r="2 RISCV Assembly",m={unversionedId:"cs/Computer_Architecture/Arch_2",id:"cs/Computer_Architecture/Arch_2",title:"2 RISCV Assembly",description:"RISC-V Architecture",source:"@site/docs/cs/Computer_Architecture/Arch_2.md",sourceDirName:"cs/Computer_Architecture",slug:"/cs/Computer_Architecture/Arch_2",permalink:"/docs/cs/Computer_Architecture/Arch_2",draft:!1,editUrl:"https://github.com/zxc2012/zxc2012.github.io/tree/master/docs/cs/Computer_Architecture/Arch_2.md",tags:[],version:"current",frontMatter:{},sidebar:"cs",previous:{title:"1 Number Representation",permalink:"/docs/cs/Computer_Architecture/Arch_1"},next:{title:"3 RISCV Single-Cycle Control and Pipelining",permalink:"/docs/cs/Computer_Architecture/Arch_3"}},p={},i=[{value:"RISC-V Architecture",id:"risc-v-architecture",level:2},{value:"RISC-V Instructions",id:"risc-v-instructions",level:2},{value:"Assembly Syntax",id:"assembly-syntax",level:3},{value:"Example",id:"example",level:3},{value:"Calling a function",id:"calling-a-function",level:2},{value:"Instruction Format",id:"instruction-format",level:2},{value:"I format",id:"i-format",level:3},{value:"SB format",id:"sb-format",level:3},{value:"U and UJ format",id:"u-and-uj-format",level:3}],u={toc:i};function o(t){let{components:e,...a}=t;return(0,l.kt)("wrapper",(0,n.Z)({},u,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"2-riscv-assembly"},"2 RISCV Assembly"),(0,l.kt)("h2",{id:"risc-v-architecture"},"RISC-V Architecture"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Register Size: 1 word = 32 bits = 4 bytes")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"32 registers:"),(0,l.kt)("p",{parentName:"li"},"  x0(holds the value zero)-x31"),(0,l.kt)("p",{parentName:"li"},"  ",(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220317214717.png",alt:"20220310173933"}))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Byte Ordering "),(0,l.kt)("p",{parentName:"li"},"  Little Endian(x86, ARM)"),(0,l.kt)("p",{parentName:"li"},"  Eg: 0x01234567"),(0,l.kt)("p",{parentName:"li"},"  ",(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220316203925.png",alt:"20220310173933"}))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Sign Extend: Take the most-significant bit and copy it to the new bits"))),(0,l.kt)("h2",{id:"risc-v-instructions"},"RISC-V Instructions"),(0,l.kt)("h3",{id:"assembly-syntax"},"Assembly Syntax"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220316201927.png",alt:"20220310173933"})),(0,l.kt)("p",null,"no-op: an instruction that does nothing"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-armasm"},"add x0,x0,x0  # Writes to x0 are always ignored\n")),(0,l.kt)("p",null,"Shifting Instructions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"When using immediate, only values 0-31 are practical"),(0,l.kt)("li",{parentName:"ul"},"When using variable, only lowest 5 bits are used (read as unsigned)")),(0,l.kt)("p",null,"Data Transfer Instructions"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"sw/lw"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-verilog"},"Store word: M[R[rs1]+imm](31:0) = R[rs2](31:0)//rs1:transfer\u7684\u7ed3\u679c\nLoad word: R[rd] = M[R[rs1]+imm](31:0)\n"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"sb/lb"),(0,l.kt)("p",{parentName:"li"},"  on sb, upper 24 bits are ignored"),(0,l.kt)("p",{parentName:"li"},"  On lb, upper 24 bits are filled by sign-extension"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-verilog"},"Store Byte: M[R[rs1]+imm](7:0) = R[rs2](7:0)\nLoad Byte: R[rd] = {24\u2019bM[](7), M[R[Rs1]+imm](7:0)}\n"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"others"),(0,l.kt)("p",{parentName:"li"},"  On sh, upper 16 bits are ignored"),(0,l.kt)("p",{parentName:"li"},"  On lh, upper 16 bits are filled by sign-extension"),(0,l.kt)("p",{parentName:"li"},"  On l(b/h)u, upper bits are filled by zero-extension"))),(0,l.kt)("p",null,"For e.g.,  s0 = 0x00000180 (all 32 bits)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-armasm"},"lb s1,1(s0) # s1 = 0x00000001\nlb s2,0(s0) # s2 = 0xFFFFFF80\nsb s2,2(s0) # *(s0) = 0x00800180\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"\u5e38\u89c1\u9519\u8bef")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-armasm"},"add x10,x11,4(x12) # \u5fc5\u987b\u5148lw\u518dadd\n")),(0,l.kt)("p",null,"branches"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"conditional branch",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"branch if equal (beq) or branch if not equal (bne)"),(0,l.kt)("li",{parentName:"ul"},"branch if less than (blt) and branch if greater than or equal (bge)"))),(0,l.kt)("li",{parentName:"ul"},"unconditional branch",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-armasm"},"j label # pseudo-code \njal dst label # Writes PC+4 to dst, set PC=lable\njalr dst src imm # Writes PC+4 to dst, set PC=src+imm\njr ra # pseudo-code:ret = jr ra = jalr x0, ra, 0\n")))),(0,l.kt)("h3",{id:"example"},"Example"),(0,l.kt)("p",null,"C Loop Mapped to RISC-V Assembly"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"int A[20];\nint sum = 0;\nfor (int i=0; i<20; i++)\nsum +=  A[i];\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-armasm"},"# Assume x8 holds pointer to A\n# Assign x10=sum\nadd x10, x0, x0 # sum=0\nadd x11, x0, x8 # Copy of A\naddi x12,x11, 80 # x12=80 + A\nloop:\n    lw x13, 0(x11)\n    add x10, x10, x13\n    addi x11, x11, 4\n    blt x11, x12, loop\n")),(0,l.kt)("h2",{id:"calling-a-function"},"Calling a function"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220616161007.png",alt:"20220616161007"})),(0,l.kt)("p",null,"Callee Saved(registers are\texpected to\tbe the same\tbefore and after a function call)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"s0-s11 (saved registers)"),(0,l.kt)("li",{parentName:"ul"},"sp (stack\tpointer)")),(0,l.kt)("p",null,"Caller Saved(These registers can be\tfreely\tchanged by the calleE,caller must save those values\tbefore making a procedure call)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"t0-t6 (temporary registers)"),(0,l.kt)("li",{parentName:"ul"},"a0-a7 (function arguments)"),(0,l.kt)("li",{parentName:"ul"},"ra (return address)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"because ra will change if\tcalleE invokes another function")))),(0,l.kt)("p",null,"Choosing Your Registers"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Function does NOT call another function",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"just use t0-t6 and there is nothing to save"))),(0,l.kt)("li",{parentName:"ul"},"Function calls other functions",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Values you need throughout go\tin s0-s11, others go\tin t0-t6")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-armasm"},"Prologue:\naddi sp,sp, -framesize\nsw ra, <framesize-4>(sp) # \u6b21\u4e8c\u9ad8,\u968f\u540e\u9010\u7ea7\u9012\u51cf\n#store other callee saved registers\n#save other regs if need be\nBody:\n\nEpilogue:\n#restore other regs if need be\n#restore other callee saved registers\nlw ra, <framesize-4>(sp)\naddi sp,sp, framesize\njr ra\n")),(0,l.kt)("p",null,"E.g."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"int sumSquare(int x, int y) {\n    return mult(x,x)+ y; \n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-armasm"},"# Prologue\naddi sp,sp,-8 # make space on stack\nsw ra, 4(sp) # save ret addr\nsw a1, 0(sp) # save y\nadd a1,a0,x0 # set 2nd mult arg\n\n# Body\njal mult # call mult\n\n# Epilogue\nlw a1, 0(sp) # restore y\nadd a0,a0,a1 # ret val = mult(x,x)+y\nlw ra, 4(sp) # get ret addr\naddi sp,sp,8 # restore stack\njr ra\n\nmult: \n")),(0,l.kt)("h2",{id:"instruction-format"},"Instruction Format"),(0,l.kt)("table",null,(0,l.kt)("thead",null,(0,l.kt)("tr",null,(0,l.kt)("th",null,"Type"),(0,l.kt)("th",null,"7"),(0,l.kt)("th",null,"5"),(0,l.kt)("th",null,"5"),(0,l.kt)("th",null,"3"),(0,l.kt)("th",null,"5"),(0,l.kt)("th",null,"7"),(0,l.kt)("th",null,"comments"))),(0,l.kt)("tbody",null,(0,l.kt)("tr",null,(0,l.kt)("td",null,"R"),(0,l.kt)("td",null,"funct7"),(0,l.kt)("td",null,"rs2"),(0,l.kt)("td",null,"rs1"),(0,l.kt)("td",null,"funct3"),(0,l.kt)("td",null,"rd"),(0,l.kt)("td",null,"opcode"),(0,l.kt)("td",null,"add,xor,mul ")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"I"),(0,l.kt)("td",{colSpan:"2"},"imm[11:0]"),(0,l.kt)("td",null,"rs1"),(0,l.kt)("td",null,"funct3"),(0,l.kt)("td",null,"rd"),(0,l.kt)("td",null,"opcode"),(0,l.kt)("td",null,"lw, jalr, slli")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"S"),(0,l.kt)("td",null,"imm[11:5]"),(0,l.kt)("td",null,"rs2"),(0,l.kt)("td",null,"rs1"),(0,l.kt)("td",null,"funct3"),(0,l.kt)("td",null,"imm[4:0]"),(0,l.kt)("td",null,"opcode"),(0,l.kt)("td",null,"rs1--transfer\u7684\u7ed3\u679c")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"SB(Branch)"),(0,l.kt)("td",null,"imm[12,10:5]"),(0,l.kt)("td",null,"rs2"),(0,l.kt)("td",null,"rs1"),(0,l.kt)("td",null,"funct3"),(0,l.kt)("td",null,"imm[4:1, 11]"),(0,l.kt)("td",null,"opcode"),(0,l.kt)("td",null,"imm: lowest bit of offset is always zero")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"U"),(0,l.kt)("td",{colSpan:"4"},"imm[31:12]"),(0,l.kt)("td",null,"rd"),(0,l.kt)("td",null,"opcode"),(0,l.kt)("td",null,"lui,auipc")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"UJ"),(0,l.kt)("td",{colSpan:"4"},"imm[20,10:1,11, 19:12]"),(0,l.kt)("td",null,"rd"),(0,l.kt)("td",null,"opcode"),(0,l.kt)("td",null,"jal")))),(0,l.kt)("h3",{id:"i-format"},"I format"),(0,l.kt)("p",null,"12-bit immediate must be sign-extended to 32 bits"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220616165009.png",alt:"20220616165009"})),(0,l.kt)("h3",{id:"sb-format"},"SB format"),(0,l.kt)("p",null,(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("mo",{parentName:"mrow"},"\u2212"),(0,l.kt)("msup",{parentName:"mrow"},(0,l.kt)("mn",{parentName:"msup"},"2"),(0,l.kt)("mn",{parentName:"msup"},"12"))),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"-2^{12}")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8974em",verticalAlign:"-0.0833em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"\u2212"),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord"},"2"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"12")))))))))))))," to ",(0,l.kt)("span",{parentName:"p",className:"math math-inline"},(0,l.kt)("span",{parentName:"span",className:"katex"},(0,l.kt)("span",{parentName:"span",className:"katex-mathml"},(0,l.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,l.kt)("semantics",{parentName:"math"},(0,l.kt)("mrow",{parentName:"semantics"},(0,l.kt)("msup",{parentName:"mrow"},(0,l.kt)("mn",{parentName:"msup"},"2"),(0,l.kt)("mn",{parentName:"msup"},"12")),(0,l.kt)("mo",{parentName:"mrow"},"\u2212"),(0,l.kt)("mn",{parentName:"mrow"},"2")),(0,l.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"2^{12}-2")))),(0,l.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8974em",verticalAlign:"-0.0833em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},(0,l.kt)("span",{parentName:"span",className:"mord"},"2"),(0,l.kt)("span",{parentName:"span",className:"msupsub"},(0,l.kt)("span",{parentName:"span",className:"vlist-t"},(0,l.kt)("span",{parentName:"span",className:"vlist-r"},(0,l.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,l.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,l.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,l.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},(0,l.kt)("span",{parentName:"span",className:"mord mtight"},"12"))))))))),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,l.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,l.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,l.kt)("span",{parentName:"span",className:"base"},(0,l.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,l.kt)("span",{parentName:"span",className:"mord"},"2")))))," = offset(byte)"),(0,l.kt)("h3",{id:"u-and-uj-format"},"U and UJ format"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-armasm"},"# Load Upper Immediate,clears the lower 12 bits\nlui rd, immediate   #rd = (immediate[31:12] << 12)\n# Add Upper Immediate to PC\nauipc rd, immediate    #rd = pc+(immediate[31:12] << 12)\n")),(0,l.kt)("p",null,"E.g. How to set 0xDEADBEEF?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-armasm"},"# Wrong answer\nlui x10, 0xDEADB # x10 = 0xDEADB000\naddi x10, x10,0xEEF # if top bit of the 12-bit immediate is a 1, it will subtract -1 from upper 20 bits,thus x10 = 0xDEADAEEF\n\n# Right\nlui x10, 0xDEADC # x10 = 0xDEADC000\naddi x10, x10,0xEEF # x10 = 0xDEADBEEF\n\n#  Call function at any 32-bit absolute address\nlui x1, <hi 20 bits>\njalr ra, x1, <lo 12 bits>\n\n# Jump PC-relative with 32-bit offset\nauipc x1, <hi 20 bits>\njalr x0, x1, <lo 12 bits>\n")))}o.isMDXComponent=!0}}]);