"use strict";(self.webpackChunkChance=self.webpackChunkChance||[]).push([[4027],{5093:(t,a,e)=>{e.r(a),e.d(a,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var n=e(7462),l=(e(7294),e(3905));e(1839);const r={},i="3 Data Structure",s={unversionedId:"cs/Math/Math_3",id:"cs/Math/Math_3",title:"3 Data Structure",description:"Hashmap",source:"@site/docs/cs/Math/Math_3.md",sourceDirName:"cs/Math",slug:"/cs/Math/Math_3",permalink:"/docs/cs/Math/Math_3",draft:!1,editUrl:"https://github.com/zxc2012/zxc2012.github.io/tree/master/docs/cs/Math/Math_3.md",tags:[],version:"current",frontMatter:{},sidebar:"cs",previous:{title:"2 Graph",permalink:"/docs/cs/Math/Math_2"},next:{title:"4 Probability",permalink:"/docs/cs/Math/Math_4"}},p={},d=[{value:"Hashmap",id:"hashmap",level:2},{value:"Separate Chaining Data Indexed Array",id:"separate-chaining-data-indexed-array",level:3},{value:"Open Addressing",id:"open-addressing",level:3},{value:"List,Set,Map",id:"listsetmap",level:2},{value:"Heap",id:"heap",level:2}],h={toc:d};function u(t){let{components:a,...e}=t;return(0,l.kt)("wrapper",(0,n.Z)({},h,e,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"3-data-structure"},"3 Data Structure"),(0,l.kt)("h2",{id:"hashmap"},"Hashmap"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Implement"),(0,l.kt)("th",{parentName:"tr",align:null},"contains(x)"),(0,l.kt)("th",{parentName:"tr",align:null},"add(x)"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Bushy BSTs"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(log N)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(log N)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Separate Chaining Hash Table With No Resizing"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(N)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(N)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"\u2026 With Resizing"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(1)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(1)")))),(0,l.kt)("h3",{id:"separate-chaining-data-indexed-array"},"Separate Chaining Data Indexed Array"),(0,l.kt)("p",null,"Data is converted into a hash code. The hash code is then reduced to a valid index."),(0,l.kt)("p",null,"Java\u2019s hashCode() function for Strings"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"public int hashCode() {// From Left to right: High to Low\n    int h = cachedHashValue;\n    if (h == 0 && this.length() > 0) {\n        for (int i = 0; i < this.length(); i++) {\n            h = 31 * h + this.charAt(i);\n        }\n        cachedHashValue = h;\n    }\n    return h;\n}\n")),(0,l.kt)("p",null,"31: the hashCode base should be a small ",(0,l.kt)("strong",{parentName:"p"},"prime")," to avoid overflow"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20221120134556.png",alt:"20221120134556"})),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20221120135107.png",alt:"20221120135107"})),(0,l.kt)("p",null,"suppose the number of buckets: M, number of items: N"),(0,l.kt)("p",null,"then complexities of contains and add are O(Q = N/M) "),(0,l.kt)("p",null,"To make them O(1), strategy: When N/M is \u2265 1.5, double M"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"bool contains(int x, vector<list<int>>& hash_table){\n    int n = hash_table.size();\n    int index = (x%n + n)%n;\n    list<int>& slot = hash_table[index]; \n    return find(slot.begin(),slot.end(),x)!=slot.end();\n}\nbool add(int x,vector<list<int>>& hash_table){\n    int n = hash_table.size();\n    int index = (x%n + n)%n;\n    hash_table[index].push_back(x);\n}\n")),(0,l.kt)("h3",{id:"open-addressing"},"Open Addressing"),(0,l.kt)("p",null,"An alternate way to handle collisions is to use open addressing"),(0,l.kt)("p",null,"If target bucket is already occupied, use a different bucket"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Linear probing",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Use next address, and if already occupied, just keep scanning one by one."))),(0,l.kt)("li",{parentName:"ul"},"Quadratic probing",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Use next address, and if already occupied, try looking 4 ahead, then 9 ahead, then 16 ahead, ...")))),(0,l.kt)("h2",{id:"listsetmap"},"List,Set,Map"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20230524204202.png",alt:"20230524204202"})),(0,l.kt)("h2",{id:"heap"},"Heap"),(0,l.kt)("p",null,"Binary heap: Binary tree that is complete and obeys heap property"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Min-heap: Every node is less than or equal to both of its children"),(0,l.kt)("li",{parentName:"ul"},"Max-heap: Every node is greater than or equal to both of its children")),(0,l.kt)("p",null,"Priority Queue Implementation"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Implement"),(0,l.kt)("th",{parentName:"tr",align:null},"Ordered Array"),(0,l.kt)("th",{parentName:"tr",align:null},"Bushy BST"),(0,l.kt)("th",{parentName:"tr",align:null},"Hash Table"),(0,l.kt)("th",{parentName:"tr",align:null},"Heap"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"add"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(N)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(log N)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(1)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(log N)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"getSmallest"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(1)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(log N)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(N)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(1)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"removeSmallest"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(N)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(log N)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(N)"),(0,l.kt)("td",{parentName:"tr",align:null},"\u0398(log N)")))))}u.isMDXComponent=!0}}]);