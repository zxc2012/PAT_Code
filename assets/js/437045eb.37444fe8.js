"use strict";(self.webpackChunkChance=self.webpackChunkChance||[]).push([[5778],{7807:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),l=(n(7294),n(3905));n(8209);const r={},i="1 Abstraction",o={unversionedId:"cs/Network/network1",id:"cs/Network/network1",title:"1 Abstraction",description:"Basic",source:"@site/docs/cs/Network/network1.md",sourceDirName:"cs/Network",slug:"/cs/Network/network1",permalink:"/docs/cs/Network/network1",draft:!1,editUrl:"https://github.com/zxc2012/zxc2012.github.io/tree/master/docs/cs/Network/network1.md",tags:[],version:"current",frontMatter:{},sidebar:"cs",previous:{title:"6 Approximation and Randomized Algorithm",permalink:"/docs/cs/Math/Math_6"},next:{title:"1 Abstraction",permalink:"/docs/cs/Operating_System/OS_1"}},s={},p=[{value:"Basic",id:"basic",level:2},{value:"Application Layer",id:"application-layer",level:2},{value:"HTTP",id:"http",level:3},{value:"HTTP connections: two types",id:"http-connections-two-types",level:4},{value:"HTTP 2 and 3",id:"http-2-and-3",level:4},{value:"Primary Methods",id:"primary-methods",level:4},{value:"Transport Layer",id:"transport-layer",level:2},{value:"Multiplexing and demultiplexing",id:"multiplexing-and-demultiplexing",level:3},{value:"TCP",id:"tcp",level:3},{value:"Establishing and Closing Connection",id:"establishing-and-closing-connection",level:4}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"1-abstraction"},"1 Abstraction"),(0,l.kt)("h2",{id:"basic"},"Basic"),(0,l.kt)("p",null,"Internet protocol stack"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Application: supporting network applications"),(0,l.kt)("li",{parentName:"ul"},"Transport: process-process data transfer"),(0,l.kt)("li",{parentName:"ul"},"Network: routing of datagrams from source to destination"),(0,l.kt)("li",{parentName:"ul"},"Data Link: data transfer between neighboring network elements"),(0,l.kt)("li",{parentName:"ul"},"Physical: bits to/from signals \u201con the wire\u201d")),(0,l.kt)("h2",{id:"application-layer"},"Application Layer"),(0,l.kt)("h3",{id:"http"},"HTTP"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"hypertext transfer protocol")),(0,l.kt)("p",null,"HTTP uses TCP:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Resolve the server to IP address (DNS)"),(0,l.kt)("li",{parentName:"ol"},"Set up TCP connection to the server"),(0,l.kt)("li",{parentName:"ol"},"Send HTTP request for the page"),(0,l.kt)("li",{parentName:"ol"},"Await HTTP response for the page"),(0,l.kt)("li",{parentName:"ol"},"Execute and fetch embedded resources, render"),(0,l.kt)("li",{parentName:"ol"},"Clean up any idle TCP connections")),(0,l.kt)("p",null,'HTTP is "stateless": server maintains no information about past client requests'),(0,l.kt)("h4",{id:"http-connections-two-types"},"HTTP connections: two types"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Non-persistent HTTP: at most one object sent over TCP connection, downloading multiple objects required multiple connections"),(0,l.kt)("li",{parentName:"ul"},"Persistent HTTP: multiple objects can be sent over single TCP connection between client, and that server")),(0,l.kt)("p",null,"RTT: Round Travel Time"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20230331210236.png",alt:"20230331210236"})),(0,l.kt)("p",null,"Non-persistent HTTP response time =  2RTT+ file transmission  time"),(0,l.kt)("p",null,"Non-persistent HTTP issues:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"requires 2 RTTs per object"),(0,l.kt)("li",{parentName:"ul"},"OS overhead for each TCP connection"),(0,l.kt)("li",{parentName:"ul"},"browsers often open multiple parallel TCP connections to fetch referenced objects in parallel")),(0,l.kt)("p",null,"Persistent HTTP(HTTP1.1):"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"server leaves connection open after sending response"),(0,l.kt)("li",{parentName:"ul"},"subsequent HTTP messages  between same client/server sent over open connection"),(0,l.kt)("li",{parentName:"ul"},"client sends requests as soon as it encounters a referenced object"),(0,l.kt)("li",{parentName:"ul"},"as little as one RTT for all the referenced objects (cutting response time significantly)")),(0,l.kt)("h4",{id:"http-2-and-3"},"HTTP 2 and 3"),(0,l.kt)("p",null,"HTTP1.1: introduced multiple, pipelined GETs over single TCP connection"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"server responds in-order (FCFS) to GET requests"),(0,l.kt)("li",{parentName:"ul"},"with FCFS, small object may have to wait for transmission  (head-of-line (HOL) blocking) behind large object(s)"),(0,l.kt)("li",{parentName:"ul"},"loss recovery (retransmitting lost TCP segments) stalls object transmission")),(0,l.kt)("p",null,"HTTP/2: decrease delay in multi-object HTTP requests"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"methods, status codes, most header fields unchanged from HTTP 1.1"),(0,l.kt)("li",{parentName:"ul"},"transmission order of requested objects based on client-specified object priority (not necessarily FCFS)"),(0,l.kt)("li",{parentName:"ul"},"push unrequested objects to client"),(0,l.kt)("li",{parentName:"ul"},"divide objects into frames, schedule frames to mitigate HOL blocking")),(0,l.kt)("p",null,"HTTP/2 over single TCP connection means:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"recovery from packet loss still stalls all object transmissions"),(0,l.kt)("li",{parentName:"ul"},"no security over vanilla TCP connection")),(0,l.kt)("p",null,"HTTP/3: adds security, per object error- and congestion-control (more pipelining) over UDP"),(0,l.kt)("h4",{id:"primary-methods"},"Primary Methods"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"GET gets data"),(0,l.kt)("li",{parentName:"ul"},"POST creates data"),(0,l.kt)("li",{parentName:"ul"},"PUT modifies data"),(0,l.kt)("li",{parentName:"ul"},"DELETE deletes data")),(0,l.kt)("p",null,"Status Code"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Code"),(0,l.kt)("th",{parentName:"tr",align:null},"Meaning"),(0,l.kt)("th",{parentName:"tr",align:null},"Examples"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"1xx"),(0,l.kt)("td",{parentName:"tr",align:null},"Information"),(0,l.kt)("td",{parentName:"tr",align:null},"100 = server agrees to handle client's request")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"2xx"),(0,l.kt)("td",{parentName:"tr",align:null},"Success"),(0,l.kt)("td",{parentName:"tr",align:null},"200 = request succeeded; 204 = no content present")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"3xx"),(0,l.kt)("td",{parentName:"tr",align:null},"Redirection"),(0,l.kt)("td",{parentName:"tr",align:null},"301 = page moved; 304 = cached page still valid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"4xx"),(0,l.kt)("td",{parentName:"tr",align:null},"Client error"),(0,l.kt)("td",{parentName:"tr",align:null},"403 = forbidden page; 404 = page not found")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"5xx"),(0,l.kt)("td",{parentName:"tr",align:null},"Server error"),(0,l.kt)("td",{parentName:"tr",align:null},"500 = internal server error; 503 = try again later error")))),(0,l.kt)("p",null,"URL"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"uniform resource locator")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-html"},"<protocol>://<hostname>/<path>\uff1f<query>#<fragment_id>\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"fragment_id")," points to the HTML element with the given ID"),(0,l.kt)("h2",{id:"transport-layer"},"Transport Layer"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"TCP: Transmission Control Protocol",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"reliable, in-order delivery"),(0,l.kt)("li",{parentName:"ul"},"flow control: sender won\u2019t overwhelm receiver "),(0,l.kt)("li",{parentName:"ul"},"congestion control: throttle sender when network overloaded "),(0,l.kt)("li",{parentName:"ul"},"connection-oriented: handshaking initializes sender, receiver state before data exchange"))),(0,l.kt)("li",{parentName:"ul"},"UDP: User Datagram Protocol",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"unreliable, unordered delivery"),(0,l.kt)("li",{parentName:"ul"},"connectionless: no handshaking between UDP sender, receiver"))),(0,l.kt)("li",{parentName:"ul"},"services not available:  delay guarantees, bandwidth guarantees")),(0,l.kt)("h3",{id:"multiplexing-and-demultiplexing"},"Multiplexing and demultiplexing"),(0,l.kt)("p",null,"Multiplexing, demultiplexing: based on segment, datagram header field values"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"TCP: demultiplexing using 4-tuple: source and destination IP addresses, and port numbers"),(0,l.kt)("li",{parentName:"ul"},"UDP: demultiplexing using destination port number (only)")),(0,l.kt)("h3",{id:"tcp"},"TCP"),(0,l.kt)("p",null,'Sequence numbers: byte stream "number" of first byte in segment\u2019s data'),(0,l.kt)("p",null,"Acknowledgements: seq # of next byte expected from other side or cumulative ACK"),(0,l.kt)("h4",{id:"establishing-and-closing-connection"},"Establishing and Closing Connection"),(0,l.kt)("p",null,"Problems with 2-way handshake: "),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"half open connection(no client)"),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20230330221212.png",alt:"20230330221212"}))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"duplicate data accepted"),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20230330221421.png",alt:"20230330221421"})))),(0,l.kt)("p",null,"3-way handshake"),(0,l.kt)("p",null,"Client sends a SYN to Server\nServer returns a SYN acknowledgment (SYN ACK)\nClient sends an ACK to acknowledge the SYN ACK"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20230330223312.png",alt:"20230330223312"})),(0,l.kt)("p",null,"4-way handshake"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"client, server each close their side of connection",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"send TCP segment with FIN bit = 1"))),(0,l.kt)("li",{parentName:"ul"},"respond to received FIN with ACK",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"on receiving FIN, ACK can be combined with own FIN"))),(0,l.kt)("li",{parentName:"ul"},"simultaneous FIN exchanges can be handled")),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20230330223828.png",alt:"20230330223828"})),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20230330225014.png",alt:"20230330225014"})))}c.isMDXComponent=!0}}]);