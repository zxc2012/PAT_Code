"use strict";(self.webpackChunkChance=self.webpackChunkChance||[]).push([[6718],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>h});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),u=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},c=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=u(r),h=i,d=m["".concat(s,".").concat(h)]||m[h]||p[h]||a;return r?n.createElement(d,l(l({ref:t},c),{},{components:r})):n.createElement(d,l({ref:t},c))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,l=new Array(a);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var u=2;u<a;u++)l[u]=r[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},8331:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>u});var n=r(7462),i=(r(7294),r(3905));const a={},l="CS162 Lecture3 --Scheduling",o={unversionedId:"cs/cs162_3",id:"cs/cs162_3",title:"CS162 Lecture3 --Scheduling",description:"Basic",source:"@site/docs/cs/cs162_3.md",sourceDirName:"cs",slug:"/cs/cs162_3",permalink:"/docs/cs/cs162_3",draft:!1,editUrl:"https://github.com/zxc2012/zxc2012.github.io/tree/master/docs/cs/cs162_3.md",tags:[],version:"current",frontMatter:{},sidebar:"cs",previous:{title:"CS162 Lecture2 --Synchronization",permalink:"/docs/cs/cs162_2"},next:{title:"CS186 Lecture1 --Relational Model & SQL",permalink:"/docs/cs/cs186_1"}},s={},u=[{value:"Basic",id:"basic",level:2},{value:"Policies",id:"policies",level:2},{value:"FCFS",id:"fcfs",level:3},{value:"SJF",id:"sjf",level:3},{value:"SRTF",id:"srtf",level:3},{value:"RR",id:"rr",level:3},{value:"MLFQ",id:"mlfq",level:3},{value:"Static Priority Scheduling",id:"static-priority-scheduling",level:4},{value:"Multi-Level Feedback Queue",id:"multi-level-feedback-queue",level:4},{value:"More scheduling policy",id:"more-scheduling-policy",level:2},{value:"Linux O(1)",id:"linux-o1",level:3}],c={toc:u};function p(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"cs162-lecture3---scheduling"},"CS162 Lecture3 --Scheduling"),(0,i.kt)("h2",{id:"basic"},"Basic"),(0,i.kt)("p",null,"Design Objectives"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Response Time: the time from when the job\narrives to the first time it is scheduled($T",(0,i.kt)("em",{parentName:"li"},"{firstrun}-T"),"{arrival}$)"),(0,i.kt)("li",{parentName:"ul"},"Turnaround time: total time needed to complete a\njob($T",(0,i.kt)("em",{parentName:"li"},"{completion}-T"),"{arrival}$)"),(0,i.kt)("li",{parentName:"ul"},"Fairness: give each thread its fair share")),(0,i.kt)("p",null,"Assumptions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Each job runs for the same amount of time"),(0,i.kt)("li",{parentName:"ul"},"All jobs arrive at the same time"),(0,i.kt)("li",{parentName:"ul"},"Once started, each job runs to completion"),(0,i.kt)("li",{parentName:"ul"},"All jobs only use the CPU (no I/O)"),(0,i.kt)("li",{parentName:"ul"},"The run-time of each job is known")),(0,i.kt)("h2",{id:"policies"},"Policies"),(0,i.kt)("h3",{id:"fcfs"},"FCFS"),(0,i.kt)("p",null,"First-Come-First-Served"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Relax assumption 1: jobs take the same amount of time")),(0,i.kt)("p",null,"Consider $T_1$,$T_2$,$T_3$ sequence of scheduling"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Average response time for (1): 17"),(0,i.kt)("li",{parentName:"ul"},"Average response time for (2): 3")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220531215934.png",alt:"20220531215934"})),(0,i.kt)("p",null,"Problem: Short processes stuck behind long processes"),(0,i.kt)("h3",{id:"sjf"},"SJF"),(0,i.kt)("p",null,"Shortest Job First->We can choose(2)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Relax assumption 2: All jobs arrive at the same time")),(0,i.kt)("h3",{id:"srtf"},"SRTF"),(0,i.kt)("p",null,"Shortest Remaining Time First"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220601202121.png",alt:"20220601202121"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Relax assumption 3: Once started, each job runs to completion")),(0,i.kt)("h3",{id:"rr"},"RR"),(0,i.kt)("p",null,"Round Robin"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'Give out small units of CPU time ("time quantum")'),(0,i.kt)("li",{parentName:"ul"},"When quantum expires, preempt, and schedule",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Round Robin: add to end of the queue"))),(0,i.kt)("li",{parentName:"ul"},"Each of N processes gets ~1/N of CPU (in window)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"With quantum length Q ms, process waits at most (N-1)*Q ms to run again"))),(0,i.kt)("li",{parentName:"ul"},"Downside: More context switches")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220601210906.png",alt:"20220601210906"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Relax assumption 4: All jobs only use the CPU (no I/O)")),(0,i.kt)("p",null,"with SRTF, we treat each sub-job as an independent one"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220601211540.png",alt:"20220601211540"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Relax assumption 5: The run-time of each job is known")),(0,i.kt)("h3",{id:"mlfq"},"MLFQ"),(0,i.kt)("h4",{id:"static-priority-scheduling"},"Static Priority Scheduling"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20220602211459.png",alt:"20220602211459"})),(0,i.kt)("p",null,"Problem: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Low priority thread might never run"),(0,i.kt)("li",{parentName:"ul"},"Deadlock: A high-priority thread H becomes ready to run when a low-priority thread L is in the critical section, H waits forever->Medium Priority will be chosen")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"DeadLock Solution"),': H temporarily grants L its "high priority" to run on its behalf'),(0,i.kt)("h4",{id:"multi-level-feedback-queue"},"Multi-Level Feedback Queue"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If Priority(A) > Priority(B), A runs"),(0,i.kt)("li",{parentName:"ul"},"If Priority(A) = Priority(B), A & B run in RR"),(0,i.kt)("li",{parentName:"ul"},"When a job enters, it has the highest priority(MLFQ approximates preemptive SJF)"),(0,i.kt)("li",{parentName:"ul"},"Job Exceeds Quantum: Drop to lower queue(CPU Bound)"),(0,i.kt)("li",{parentName:"ul"},"Job Doesn't Exceed Quantum: Raise to higher queue(I/O Bound)"),(0,i.kt)("li",{parentName:"ul"},"After some time period, move all the jobs in the\nsystem to the topmost queue")),(0,i.kt)("h2",{id:"more-scheduling-policy"},"More scheduling policy"),(0,i.kt)("h3",{id:"linux-o1"},"Linux O(1)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"140 priorities in total, 200 ms (highest priority) to 10 ms time slice"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Active")," and ",(0,i.kt)("em",{parentName:"li"},"expired")," queues at each priority,each element in the queue is a linked list of threads"),(0,i.kt)("li",{parentName:"ul"},"threads in a certain priority: round-robin fashion"),(0,i.kt)("li",{parentName:"ul"},"when a thread\u2019s time slice expires, it is moved to the expired array, with an adjustment to its priority level")),(0,i.kt)("p",null,"O(1): The active and expired priority arrays will be swapped\nwhen there are no threads in the active array"))}p.isMDXComponent=!0}}]);