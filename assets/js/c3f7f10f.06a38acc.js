"use strict";(self.webpackChunkChance=self.webpackChunkChance||[]).push([[401],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),h=p(n),d=r,m=h["".concat(s,".").concat(d)]||h[d]||u[d]||l;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3530:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const l={},i="Index & Hashing",o={unversionedId:"cs/cs186_3",id:"cs/cs186_3",title:"Index & Hashing",description:"B+ Tree",source:"@site/docs/cs/cs186_3.md",sourceDirName:"cs",slug:"/cs/cs186_3",permalink:"/docs/cs/cs186_3",draft:!1,editUrl:"https://github.com/zxc2012/zxc2012.github.io/tree/master/docs/cs/cs186_3.md",tags:[],version:"current",frontMatter:{},sidebar:"cs",previous:{title:"Data Models",permalink:"/docs/cs/cs186_2"},next:{title:"CS61C Lecture1 --Number Representation",permalink:"/docs/cs/cs61c_1"}},s={},p=[{value:"B+ Tree",id:"b-tree",level:2},{value:"Structure",id:"structure",level:3},{value:"Occupancy Invariant",id:"occupancy-invariant",level:3},{value:"Insertion",id:"insertion",level:3}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"index--hashing"},"Index & Hashing"),(0,r.kt)("h2",{id:"b-tree"},"B+ Tree"),(0,r.kt)("h3",{id:"structure"},"Structure"),(0,r.kt)("p",null,"Node","[\u2026, ($P_i,K_i$), \u2026]"," "),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/zxc2012/image/main/20210528150834.png",alt:"20210528150834"})),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"$P_1$"),(0,r.kt)("th",{parentName:"tr",align:null},"$K_1$"),(0,r.kt)("th",{parentName:"tr",align:null},"$P_2$"),(0,r.kt)("th",{parentName:"tr",align:null},"..."),(0,r.kt)("th",{parentName:"tr",align:null},"$P_{n-1}$"),(0,r.kt)("th",{parentName:"tr",align:null},"$K_{n-1}$"),(0,r.kt)("th",{parentName:"tr",align:null},"$P_n$")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Every root to leaf path has the same number of edges (the height of the tree). In this\nsense, B+ trees are always balanced. "),(0,r.kt)("li",{parentName:"ul"},"Only the leaf nodes contain records (or pointers to records). The\ninner nodes (which are the non-leaf nodes) do not contain the actual records.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Leaf Node")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For i = 1, 2, ..., n\u20131, pointer $P_i$ points to a file record with search-key value $K_i$")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"$P_n$ points to next leaf node in search-key order"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Non-Leaf Node")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"All the search-keys in the subtree to which $P",(0,r.kt)("em",{parentName:"p"},"i$ points have values greater than or equal to $K"),"{i-1}$ and less than $K_i$ ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"All the search-keys in the subtree to which $P",(0,r.kt)("em",{parentName:"p"},"n$ points have values greater than or equal to $K"),"{n-1}$"))),(0,r.kt)("h3",{id:"occupancy-invariant"},"Occupancy Invariant"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each node that is not a root or a leaf has between$\\lceil n/2 \\rceil$ and n children."),(0,r.kt)("li",{parentName:"ul"},"A leaf node has between $\\lceil (n-1)/2 \\rceil$ and n\u20131 values"),(0,r.kt)("li",{parentName:"ul"},"Special cases: ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If the root is not a leaf, it has at least 2 children."),(0,r.kt)("li",{parentName:"ul"},"If the root is a leaf (that is, there are no other nodes in the tree), it can have between 0 and (n\u20131) values")))),(0,r.kt)("h3",{id:"insertion"},"Insertion"),(0,r.kt)("p",null,"To insert an entry into the B+ tree, follow this procedure:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Find the leaf node L, insert (pointer,key-value) pair in the leaf node")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"If L overflows"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"LeafNode: \u770b Key"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"(1)take the 2d+1 (pointer,search-key value) pairs (including the one being inserted,also there is a next pointer) in sorted order. Split into L1 and L2. Keep d pairs in L1 (this means d + 1 pairs will go in L2)."),(0,r.kt)("li",{parentName:"ul"},"(2)If L was a leaf node, ",(0,r.kt)("strong",{parentName:"li"},"COPY")," L2\u2019s first pair into the parent.\nIf L was not a leaf node, ",(0,r.kt)("strong",{parentName:"li"},"MOVE")," L2\u2019s first pair into the parent."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"NonLeafNode: \u770bpointers(Childrens)"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"(1) Split n+1 pointers into L1 and L2.\nKeep $\\lfloor{(n+1)/2}\\rfloor$ in L1, rest go to L2."),(0,r.kt)("li",{parentName:"ul"},"(2) ",(0,r.kt)("strong",{parentName:"li"},"MOVE")," L2\u2019s first pair(pointer\u8fd9\u91cc\u53ea\u79fb\u52a8\u7ebf,\u4e0d\u5e26\u5bf9\u8c61) into the parent."),(0,r.kt)("li",{parentName:"ul"},"(3) reorder leaves")))),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"If the parent overflows, then recurse on it by doing step 2 on the parent.")),(0,r.kt)("p",null,"Why ",(0,r.kt)("em",{parentName:"p"},"copy/move"),"?"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we want to ",(0,r.kt)("strong",{parentName:"li"},"COPY")," leaf node data into the parent so that we don\u2019t lose the data in the\nleaf node. Remember that every key that is in the table that the index is built on must be in\nthe leaf nodes! Being in a inner node does not mean that key is actually still in the table."),(0,r.kt)("li",{parentName:"ul"},"we can ",(0,r.kt)("strong",{parentName:"li"},"MOVE")," inner node data into parent nodes because the inner node does\nnot contain the actual data, they are just a reference of which way to search when traversing the tree.")))}u.isMDXComponent=!0}}]);